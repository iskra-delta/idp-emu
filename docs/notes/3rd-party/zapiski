2017-03-30

*** Kaj je na disku ***

Na hard disku so datoteke na obmo�jih 0, 3, 4, 5, 10 (Pascal koda), 14 (Fortran koda), 15 (zelo veliko Pascal in nekaj Fortran kode). Toda o�itno nikjer ni assemblerja (imenovati bi se moral MAC).

Seznam "sistemskih" *.COM datotek (dobimo jih z ukazom DIRS *.COM):
WS120, FORMAT, CCP, SETUP, WSCALL, PIP, GENCOM, ED, FUJ, SAVE, WLDR, DBASEOVR, SUBMIT, INITDIR, DEVICE, ERASE, RENAME, SETDEF, TYPE, PUTWSYS, SET, WF, HEXCOM, HELP, PUT, GET, DIR, BRUN, SETI, DATUM, DUMP, DATE, WSMJ, CLG, GRMT20, Y, URASET, WSDPMG, WSS, LOGO2, LOGO, VS, HCOPY9, CGRAF, MBASIC, IDRIS, DBASE, GPUTFSYS, TURBO, L80, M80, F80, TURBOPAR, TURBOGRF, CLR, WS1, WS, WSF, SHOW, DISKETTE, TINST, VIGRED, BAZA, MPC, MP, ZSID, GROUTPUT, FU

PROFILE.SUB (kot AUTOEXEC.BAT na DOSu) vsebuje:
CLG	(kaj to naredi, ne vem; izpi�e le "CLG Ver.: 1.2")
DEVICE AUX:=LPT[4800,XON]	(nastavi logi�no napravo AUX na serijski port, 4800 b/s, XON/XOFF)
Y	(to je analogna ura)

-----

2017-03-31

*** Testiranje I/O portov za serijski port ("LPT") ***

Izvajamo Microsoft BASIC program:

10 PRINT INP(&HDA), INP(&HDB)
20 GOTO 10

0DAh je data port, 0DBh je status port. Takoj po resetu ra�unalnika ima data port vrednost 255 ali 0, status pa 76. Po�iljanje znakov z drugega ra�unalnika (4800,N,8,1) tega ne spremeni. �e poskusimo poslati znak s pisanjem na data port, se status spremeni na 72, vendar se na drugem ra�unalniku ni�esar ne vidi.

*** Testiranje I/O portov za tipkovnico ("CRT") ***

Izvajamo Microsoft BASIC program kot zgoraj, le da spremenimo porta na &HD8 in &HD9. Takoj po ukazu RUN dobimo "13, 108"; �e pritisnemo preslednico, dobimo "32, 108". �e pritiskamo druge tipke, se vsebina data porta spremeni, status pa ostane enak (niti caps lock ga ne spremeni).

�e izvedemo OUT &HD8, &H7F, se pri�gejo vse lu�ke razen najbolj leve in najbolj desne (zakaj?). �e potem pi�emo na isti port, se stanje ne spremeni (ne na lu�kah ne na statusnem I/O portu), dokler ne pritisnemo tipke SET UP in resetiramo terminala. To pri�ge najbolj levo lu�ko in ugasne vse ostale. Verjetno nekaj zapi�e na statusni port, da lahko tipkovnica sprejme nove podatke, nato pa zapi�e 80h na data port.

�e po resetu zapi�emo 0 na data port, se najbolj leva lu�ka �e vedno ne ugasne, lahko pa potem zapi�emo novo vrednost, ne da bi morali resetirati terminal. Ko jo zapi�emo, potem spet ne moremo spremeniti stanja, ne da bi ga resetirali; pisanje 0 ne deluje.

Kaj �e lahko zapi�emo na data port:
1	Pri�gana je samo lu�ka SISTEM.
2	Tipkovnica zapiska. Ta pisk ni enak kot tisti, ki se zgodi ob vsakem pritisku tipke.
3	Pri�gana je samo lu�ka LOKALNO (druga z leve).
4	Tipkovnica zapiska kot pri vrednosti 2, vendar je pisk dalj�i.
129	Pri�gani sta lu�ki SISTEM (najbolj leva) in L5 (najbolj desna).
130	Enako kot 2?
131	Pri�gani sta lu�ki LOKALNO in L5.
132	Enako kot 4?
133	Pri�gane so lu�ke SISTEM, TAST ZAKLN. in L5. Binarno je to 10000101, kar je od desne proti levi enako kot lu�ke.
134	Enako kot 2?
135	Pri�gane so lu�ke LOKALNO, TAST ZAKLN. in L5. Binarno je to 10000111.

�e izvedemo FOR i% = 128 TO 255: OUT &HD8, i%: NEXT, se lu�ke hitro pri�igajo in uga�ajo, sli�imo nekaj piskanja, nato so pri�gane vse razen SISTEM, tipkovnica pa ve� ne piska, ko tipkamo. Resetiranje terminala povrne lu�ke, piskanja pa ne. Dobimo pa ga nazaj, �e resetiramo ra�unalnik.

-----

2017-04-02

*** Analiza zagonske diskete ("Partner F vzor�na disketa") ***

0 do 23FFh je CP/M loader; glej spodaj
2400h je blok 0 datote�nega sistema (imenik - pove nam, kje so datoteke)
3400h je blok 2 (FFLDR.COM - datoteka je identi�na(?) CP/M loaderju na za�etku diska; PUTFFSYS.COM to skopira tja)
4C00h je blok 5 (CCP.COM)
5C00h je blok 7 (PUTFFSYS.COM)
6400h je blok 8 (CPM3.SYS)

En blok datote�nega sistema je torej 2048 bajtov oz. 8 sektorjev - vsaj na disketi; na trdem disku je morda ve�. Ker imenik o�itno zaseda 2 bloka in je vsak vnos dolg 32 bajtov, je lahko najve� 128 datotek na disketi.

Analiza loaderja (primerjamo s CPMLDR.ASM iz arhiva izvorne kode CP/M 3):

Prva in�trukcija je LD SP, 281h (glej spodaj), druga pa CALL 0B00h. Slednja kli�e BIOS funkcijo 0. BIOS je na disketi na naslovu 0A00h, oz. tako predvidevam, ker je tam zaporedje JP in�trukcij. Nekatere preprosto sko�ijo na RET in�trukcije, zato to morda ni celoten BIOS, ampak le minimalna verzija, potrebna, da se nalo�i CPM3.SYS in preostanek.

Glede stack pointerja: sicer je nenavadno, da je lih naslov in ne sod, vendar nikjer ne pi�e, da ne sme biti lih. Ka�e nekam sredi loaderja (na disketi je to naslov 181h), vendar se to ujema z izvorno kodo.

-----

2017-04-03

*** Testiranje I/O portov za serijski port, part deux ***

Tokrat je vrednost na status portu po resetu 68 (44h) in ne 72 (48h). �e najprej izpi�emo status port in nato data port, se ni� ne spremeni. �e spremenimo hitrost na 1200 b/s ("DEVICE LPT[1200"), je 196 (0C4h). �e jo spremenimo na 2400 (dovoljene so samo te tri), je tudi 68! Nekaj ni jasno.

*** Testiranje I/O portov za tipkovnico, part deux ***

Ne glede, ali beremo najprej status ali data port, je status vedno 108. Tudi �e nekaj �asa ne beremo (in pustimo uporabniku, da pritisne eno ali ve� tipk), je status �e vedno 108. Tipkovnica torej uporablja prekinitev, da sporo�i, da so podatki na voljo.

Lokacija BDOS-a
Preberemo jo z naslova 6 (na naslovu 5 je JP). Na Partnerju je to 0F406h. Tam so (do vklju�no naslova 0F454h, ker se mi ne da dlje pretipkavati) bajti:
C3 24 F4 C3 E4 F6 C3 F2 F6 C3 FA F6 B5 03 FF 00 00 00 00 4E F8 80 00 00 92 F3 00 C3 77 F5 79 21 00 00 22 28 F8 39 22 66 F9 31 66 F9 21 CB F6 E5 FE 0C D2 94 F5 32 DF F9 21 86 F4 06 00 09 7E 23 66 6F E9 43 4F 50 59 52 49 47 48 54 20 28 43
Kar ni ni� uporabnega. Prve 4 in�trukcije so JP (JP 0F424h in JP 0F6E4h), nato so o�itno podatki.

Dobimo pa jih z:
10 A = &HF406
20 B$ = HEX$(PEEK(A))
25 A = A + 1
30 IF LEN(B$) = 1 THEN B$ = "0" + B$
40 PRINT B$; " ";
50 C = C + 1
60 IF C <> 256 THEN GOTO 20

*** Kode, ki jih po�ilja tipkovnica ***

Uporabljamo Microsoft BASIC program:
10 PRINT HEX$(INP(&HD8))
20 GOTO 10

Tipka	Brez	SHIFT	CTL	SHIFT + CTL
SET UP	FE	FE	F5	F5
gor	F1	F1	F1	F1
dol	F2	F2	F2	F2
levo	F3	F3	F3	F3
desno	F4	F4	F4	F4
neozn.	F5	F5	F5	F5
PF1	F6	F6	F6	F6
PF2	F7	F7	F7	F7
PF3	F8	F8	F8	F8
PF4	F9	F9	F9	F9
ESC	1B	1B	1B	1B
1 (zg.)	31	21	FF	FF
2 (zg.)	32	40	0	0
3 (zg.) 33	23	E5	E5
4 (zg.)	34	24	FF	FF
5 (zg.)	35	25	FF	FF
6 (zg.)	36	5E	FF	1E
7 (zg.)	37	26	FF	FF
8 (zg.)	38	2A	FF	FF
9 (zg.)	39	28	FF	FF
0 (zg.)	30	29	FF	FF
-	2D	5F	1F	1F
=	3D	2B	FF	FF
/?	60	7E	FF	1E
BS	8	8	8	8
BRK	E0	(op.1)	E0	E0
7(num.)	E1	E1	E1	E1
8(num.)	E2	E2	E2	E2
9(num.)	E3	E3	E3	E3
-(num.)	E4	E4	E4	E4
TAB	9	9	9	9
Q	71	51	11	11
W	77	57	17	17
E	65	45	5	5
R	72	52	12	12
T	74	54	14	14
Z	79	59	19	19
U	75	55	15	15
I	69	49	9	9
O	6F	4F	F(op.2)	F(op.2)
P	70	50	10	10
�	5B	7B	1B	1B
�	5D	7D	1D	1D
neozn.2	D4	D6	D4	D6
DEL	7F	0	7F	7F
4(num.)	D0	D0	D0	D0
5(num.)	D1	D1	D1	D1
6(num.)	D2	D2	D2	D2
,(num.)	D3	D3	D3	D3
A	61	41	1	1
S	73	53	13(op3)	13(op3)
D	64	44	4	4
F	66	46	6	6
G	67	47	7	7
H	68	48	8	8
J	6A	4A	A	A
K	6B	4B	B	B
L	6C	4C	C	C
�	3B	3A	FF	FF
�	27	22	FF	FF
RET	D	D	D	D
<>	5C	7C	1C	1C
1(num.)	C0	C0	C0	C0
2(num.)	C1	C1	C1	C1
3(num.)	C2	C2	C2	C2
neozn.3	A3	A3	A3	A3
SCR	B0	B0	B0	B0
Y	7A	5A	1A	1A
X	78	58	18	18
C	63	43	(op. 4)	(op. 4)
V	76	56	16	16
B	62	42	2	2
N	6E	4E	E	E
M	6D	4D	D	D
,	2C	3C	FF	FF
.	2E	3E	FF	FF
�	2F	3F	FF	FF
LF	A	A	A	A
0(num.)	B1	B1	B1	B1
.(num.)	B2	B2	B2	B2
ENT	C3	C3	C3	C3
(space)	20	20	20	20

Opomba 1: SHIFT+BRK nas vr�e nazaj v CCP.
Opomba 2: CTL+O in CTL+SHIFT+O o�itno delujeta kot SCR, vendar imata druga�no kodo.
Opomba 3: CTL+S tudi deluje kot SCR, vendar katerakoli tipka nadaljuje izpis.
Opomba 4: verjetno je koda 3, ker ustavi program.

Ko je CAPS vklju�en, vse tipke generirajo enake kode, kot �e ni, razen QWERTZUIOPASDFGHJKLYXCVBNM, ki generirajo enake, kot �e je pritisnjen SHIFT. Zanje takrat SHIFT nima u�inka.

*** Analiza zagonske diskete, part deux ***

Druga in�trukcija CP/M loaderja, kot smo �e rekli, je CALL 0B00h ("BOOT"). Na tistem naslovu (to je 0A00h na disketi) je JP 0B66h, tam pa le�ijo in�trukcije:

BOOT:
0B66	F3		di
0B67	3E 03		ld a, 3
0B69	D3 CA		out (0CAh), a	; "izbira vezja CTC" (kaj je to?)
0B6B	DB 80		in a, (80h)	; "izklop pomnilnika EPROM"(!) (glej spodaj)
0B6D	CD F4 0F	call 0FF4h	; (glej spodaj)
0B70	C9 		ret

Torej je EPROM do takrat �e dostopen! Toda kako je to mogo�e, �e:
* Z80 za�ne izvajati kodo na naslovu 0
* torej mora biti na naslovu 0 ROM
* vendar se CP/M loader nalo�i na naslov 100h

Oglejmo si �e funkcijo 0FF4h:

0FF4	21 64 0B	ld hl, 0B64h
0FF7	7D		ld a, l		; A := 64h
0FF8	D3 E8		out (0E8h), a	; "izbira prekinit. vektorja za FDC"
0FFA	7C		ld a, h
0FFB	ED 47		ld i, a		; I := 0Bh
0FFD	FB		ei
0FFE	C9		ret

Prekinitveni vektor za FDC o�itno nastavi na 0B64h. Na tistem naslovu je word 10FCh. Z80 ga ob prekinitvi prebere in sko�i na ta naslov. Tam je:

10FC	FB		ei
10FD	ED 4D		reti

Zakaj so potem prekinitve sploh omogo�ene? Bomo �e videli.

-----

2017-04-07

*** Analiza zagonske diskete, part trois ***

Tabela skokov zagonskega BIOSa (na disketi na 0A00h, v naslovu na 0B00h):

0B00	C3 66 0B 	jp 0B66h	; BOOT (glej zgoraj)
0B03	C3 71 0B	jp 0B71h	; WBOOT (ka�e na RET)
0B06	C3 7D 0B	jp 0B7Dh	; CONST (ka�e na RET)
0B09	C3 7D 0B	jp 0B7Dh	; CONIN (ka�e na RET)
0B0C	C3 72 0B	jp 0B72h	; CONOUT (glej spodaj)
0B0F	C3 7D 0B	jp 0B7Dh	; LIST (ka�e na RET)
0B12	C3 7D 0B	jp 0B7Dh	; PUNCH (ka�e na RET)
0B15	C3 7D 0B	jp 0B7Dh	; READER (ka�e na RET)
0B18	C3 B6 0B	jp 0BB6h	; HOME (glej spodaj)
0B1B	C3 82 0B	jp 0B82h	; SELDSK
0B1E	C3 B9 0B	jp 0BB9h	; SETTRK (glej spodaj)
0B21	C3 BF 0B	jp 0BBFh	; SETSEC
0B24	C3 D3 0B	jp 0BD3h	; SETDMA
0B27	C3 E3 0B	jp 0BE3h	; READ
0B2A	C3 09 0C	jp 0C09h	; WRITE
0B2D	C3 7D 0B	jp 0B7Dh	; LISTST (ka�e na RET)
0B30	C3 DF 0B	jp 0BDFh	; SECTRAN
0B33	C3 7D 0B	jp 0B7Dh	; CONOST (ka�e na RET)
0B36	C3 7D 0B	jp 0B7Dh	; AUXIST (ka�e na RET)
0B39	C3 7D 0B	jp 0B7Dh	; AUXOST (ka�e na RET)
0B3C	C3 1D 0C	jp 0C1Dh	; DEVTBL (ka�e na RET)
0B3F	C3 1D 0C	jp 0C1Dh	; DEVINI (ka�e na RET)
0B42	C3 B2 0B	jp 0BB2h	; DRVTBL
0B45	C3 0C 0C	jp 0C0Ch	; MULTIO
0B48	C3 10 0C	jp 0C10h	; FLUSH
0B4B	C3 1D 0C	jp 0C1Dh	; MOVE (ka�e na RET)
0B4E	C3 1D 0C	jp 0C1Dh	; TIME (ka�e na RET)
0B51	C3 7E 0B	jp 0B7Eh	; SELMEM
0B54	C3 DB 0B	jp 0BDBh	; SETBNK
0B57	C3 1D 0C	jp 0C1Dh	; XMOVE (ka�e na RET)
0B5A	C3 00 00	jp 0		; USERF
0B5D	C3 00 00	jp 0		; RESERV1
0B60	C3 00 00	jp 0		; RESERV2

CONOUT:
0B72	DB D9		in a, (0D9h)	; CRT status
0B74	E6 04		and 4
0B76	CA 72 0B	jp z, 0B72h	; �akaj, dokler je bit 2 enak 0
0B79	79		ld a, c		; A = znak za izpis
0B7A	D3 D8		out (0D8h), a	; CRT data
0B7C	C9		ret

HOME:
0BB6	01 00 00	ld bc, 0
SETTRK:
0BB9	69		ld l, c
0BBA	60		ld h, b
0BBC	22 14 0C	ld (0C14h), hl	; Word 0C14h := 0
0BBF	C9		ret

Na naslovu 6A80h je podobna tabela skokov, tudi s 33 vnosi. Nekoliko za njo je �e nekaj skokov, vendar so med njimi o�itno "prazni" bajti.

*** Testiranje I/O portov za tipkovnico, part trois ***

Hex vr.	Bin vr.	Rezultat
9	1001	10010000
A	0101	10010000, kratek pisk
B	1101	01010000
C	0011	01010000, dolg pisk
D	1011	10110000
E	0111	10110000, kratek pisk
F	1111	01110000
10	00001	01110000
11	10001	10001000
12	01001	10001000, kratek pisk
13	11001	01001000
14	00101	01001000, dolg pisk
15	10101	10101000
16	01101	10101000, kratek pisk
17	11101	01101000
18	00011	01101000
19	10011	10011000
1A	01011	10011000, kratek pisk
1B	11011	01011000
1C	00111	01011000, dolg pisk
1D	10111	10111000
1E	01111	10111000, kratek pisk
1F	11111	01111000
20	000001	01111000

Lokacija BIOS-a (ko je �e nalo�en kon�ni BIOS)
Uporabimo BASIC program. Na naslovu 0 je skok v BIOS: JP 0FA03h.
Tam so:
FA00	C3 4F 86	jp 864Fh	; BOOT
FA03	C3 D8 FA	jp 0FAD8h	; WBOOT
FA06	C3 A1 FB	jp 0FBA1h	; CONST
FA09	C3 B2 FB	jp 0FBB2h	; CONIN
FA0C	C3 75 FB	jp 0FB75h	; CONOUT
FA0F	C3 7F FB	jp 0FB7Fh	; LIST
FA12	C3 7A FB	jp 0FB7Ah	; PUNCH
FA15	C3 B7 FB	jp 0FBB7h	; READER
FA18	C3 9A 87	jp 879Ah	; HOME
FA1B	C3 78 87	jp 8778h	; SELDSK
FA1E	C3 9D 87	jp 879Dh	; SETTRK
FA21	C3 A2 87	jp 87A2h	; SETSEC
FA24	C3 A7 87	jp 87A7h	; SETDMA
FA27	C3 B6 87	jp 87B6h	; READ
FA2A	C3 DE 87	jp 87DEh	; WRITE
FA2D	C3 95 FB	jp 0FB95h	; LISTST
FA30	C3 B2 87	jp 087B2h	; SECTRAN
FA33	C3 8B FB	jp 0FB8Bh	; CONOST
FA36	C3 A6 FB	jp 0FBA6h	; AUXIST
FA39	C3 90 FB	jp 0FB90h	; AUXOST
FA3C	C3 0B FB	jp 0FB0Bh	; DEVTBL
FA3F	C3 13 FB	jp 0FB13h	; DEVINI
FA42	C3 0F FB	jp 0FB0Fh	; DRVTBL
FA45	C3 F3 87	jp 87F3h	; MULTIO
FA48	C3 F7 87	jp 87F7h	; FLUSH
FA4B	C3 5E FC	jp 0FC5Eh	; MOVE
FA4E	C3 4A FC	jp 0FC4Ah	; TIME
FA51	C3 C4 FB	jp 0FBC4h	; SELMEM
FA54	C3 AE 87	jp 087AEh	; SETBNK
FA57	C3 50 FC	jp 0FC50h	; XMOVE
FA5A	C3 75 FF	jp 0FF75h	; USERF
FA5D	C3 00 00	jp 0
FA60	C3 00 00	jp 0
FA63	C3 00 00	jp 0
FA66	C3 00 00	jp 0
FA69	C3 00 00	jp 0
FA6C	C3 00 00	jp 0
FA6F	C3 00 00	jp 0
FA72	C3 75 FF	jp 0FF75h	; Slavna funkcija 37 za grafiko
FA75	C3 00 00	jp 0
FA78	C3 00 00	jp 0
FA7B	C3 00 00	jp 0
in potem sledijo garbage(?) bajti.

-----

2017-04-10

*** Naprave v CP/M ***

Naprave so:
CRT, LPT, (prazno), (prazno), CEN, GDP

Disassembly DEVTBL:
FB0B	21 4A FD	ld hl, 0FD4Ah
FB0E	C9		ret

Tam je:
db "CRT   "
db 0Bh		; 1011b = can input, can output, supports XON/XOFF
db 0Eh		; 9600 b/s
db "LPT   "
db 1Fh		; 11111b = can input, can output, can change rate, supports XON/XOFF, is using XON/XOFF
db 0Ch
db "      "
db 0
db 0Eh
db "      "
db 0
db 6
db "CEN   "
db 2		; 10b = can output
db 0		; fiksna hitrost
db "GDP   "
db 2		; 10b = can output
db 0		; fiksna hitrost
db 0		; Terminator

Disassembly PUNCH:
FB7A	2A C4 F9	ld hl, (0F9C4h)
FB7D	18 03		jr 0FB82h
�

*** Testiranje I/O portov za serijski port, part trois ***

�e pi�emo vrednosti ("X") na status port in ga takoj beremo, za X od 0 do 17h dobimo:
(X AND 3) = 0	4Ch
(X AND 3) = 1	0Fh
(X AND 3) = 2	96h
(X AND 3) = 3	0FFh
Od 18h do 20h je vse 4Ch.
Vzorec se nadaljuje pri 21h; ta vrne 0Fh.
Nato od 58h do 60h spet dobimo le 4Ch.
Vzorec se nadaljuje pri 61h s 0Fh.
Od 98h do A0h je spet 4Ch.
A1h je spet 0Fh, vzorec se ponovi.
Od 0D8h do 0E0h je 4Ch.

Program GRMT20 lahko po�ilja znake, ki jih drug ra�unalnik prebere! Dejanska hitrost je enkrat hitrej�a, kot pravi DEVICE, format pa je 8 podatkovnih bitov, 1 stop bit, brez paritete.

-----

2017-04-18

*** Po�iljanje podatkov po serijskem portu ***

�e za�enemo GRMT20 in ga kon�amo (s CTL+D), deinicializira serijski port. �e pa ga za�enemo in nasilno prekinemo (s SHIFT+BRK), pa ga ne bo. Takrat lahko uporabimo npr. BASIC za po�iljanje podatkov:

10 FOR I% = 32 TO 126
20 IF INP(&HDB) AND 4 = 0 THEN GOTO 20
30 OUT &HDA, I%
40 NEXT

To izpi�e vse printable ASCII znake.

Po�iljanje poljubne vsebine spomina (ve�kratnik 128 bajtov) s protokolom XMODEM:

10 A = &HF406: REM To je za�etek BDOS-a; nad njim je �e BIOS
20 FOR P% = 1 TO 24: REM �tevec paketov (po 128 bajtov)
30 REM Header
40 C% = 1: GOSUB 1000: REM SOH za za�etek bloka
50 C% = P%: GOSUB 1000: REM �t. bloka
60 C% = 255 - P%: GOSUB 1000: REM Negirana �t. bloka
70 S% = 0: REM Checksum
80 FOR I% = 0 to 127
90 C% = PEEK(A): GOSUB 1000
100 S% = (S% + C%) AND 255
110 A = (A + 1) AND &HFFFF
120 NEXT I%
130 C% = S%: GOSUB 1000
140 NEXT P%
150 C% = 4: GOSUB 1000: REM EOT za konec prenosa
160 END
1000 REM Po�iljanje znakov
1010 IF INP(&HDB) AND 4 = 0 THEN GOTO 1010
1020 OUT &HDA, C%
1030 RETURN

Vendar zgornji program o�itno ne izra�una pravega checksuma - HyperTerminal in ZTerm ga ne sprejmeta (zakaj?).

Oglejmo si �e ISR za tipkovnico(?), ki je v RAM na naslovu 0FEF4h:

FEF4	PUSH	AF
FEF5	IN	A,(#D9)
FEF7	LD	A,#30
FEF9	OUT	(#D9),A		; Acknowledge?
FEFB	LD	A,(#FF25)
FEFE	OUT	(#D8),A		; Morda to spro�i zvok tipke?
FF00	POP	AF
FF01	EI
FF02	RETI

*** Analiza zagonske diskete, part quatre ***

CP/M loader prebere imenik (seznam datotek na disketi) s sledi 2, sektorja 1. Ker so sledi o�tevil�ene od 0 naprej, sektorji pa od 1 naprej, in je 18 sektorjev na sled in 256 bajtov na sektor, je 2 * 18 * 256 = 2400h, kar je pravilno.

Da nastavi �tevilko sledi, kli�e BIOS funkcijo SETTRK. Ta si na 0C14h zapomni �tevilko sledi. Da nastavi �tevilko sektorja, kli�e BIOS funkcijo SETSEC; ta si na 0C16h zapomni �tevilko sektorja, na 0C20h negiran najni�ji bit(?), na 0C1Eh pa �tevilko sektorja, deljeno z 2. Potem nastavi "DMA naslov" (torej kam se bodo podatki prebrali) na 0CCEh; kazalec na to se shrani na 0C18h.

-----

2017-04-20

Na hard disku je program WF.COM za testiranje hard diska in dokumentacija WFPRI.TXT. V tej je opisan tudi kontroler (Xebec S1410) in sam disk (Seagate ST506/412) - njegova geometrija je: 2 diska, na vsaki strani diska po 306 sledi, 32 sektorjev na sled, 256 bajtov na sektor (skupaj 10027008 bajtov). To je treba vedeti, �e �elimo direktno dostopati do njega; BIOS ima namre� funkciji SETTRK in SETSEC, s katerima povemo, katero sled in sektor na njej �elimo brati oz. pisati; �tevilke sledi so torej 0 do 1223, �tevilke sektorjev pa 1 do 32.

-----

2017-04-27

*** Analiza zagonske diskete, part cinq, in analiza CPMLDR na Winchesterju ***

BIOS, ki ga uporablja CPMLDR (na disketi ali Winchesterju), klicatelju predstavlja 128 bajtov dolge sektorje in jih sam pretvarja v prave, ki so dolgi 256 bajtov. Kon�ni BIOS pa o�itno predstavlja 256 bajtov dolge, druga�e ne bi mogli imeti slike Winchesterja.

Na Winchesterju so bloki (gru�e) dolgi 4096 bajtov. Prvih 8192 bajtov (1 sled) diska je rezerviranih za CPMLDR, naslednjih 32768 bajtov (4 sledi oz. 8 blokov) pa za imenik. Da iz �tevilke bloka dobimo naslov v sliki, ga mno�imo s 4096 in pri�tejemo 8192.

-----

2017-05-01

*** Banki ***

"Banka 0" je za CP/M tista, v kateri je CP/M. "Banka 1" je tista, v kateri je TPA. Katera banka je v rabi, se dolo�a z BIOS funkcijo SELMEM.

Na Partnerju SELMEM stori slede�e: shrani �t. banke (0 ali 1) na 0FBCAh, in �e je 1, bere s porta 90h ("vklop pomnilnika-BANK 2 RAM"). Torej banki 0 priro�nik pravi "BANK 1", banki 1 pa "BANK 2". Ali se port za izbiranje banke bere ali pi�e, o�itno ni pomembno.

Vsaka banka je dolga 0F400h bajtov. Zgornjih 0C00h bajtov spomina je skupnih. To je skupaj 125K.

-----

2017-05-20

*** Analiza pravega keyboard interrupt handlerja ***

Glej dodatek E v priro�niku za njegov naslov.

FEA7	PUSH	AF
FEA8	PUSH	BC
; Preberemo kodo pritisnjene tipke.
FEA9	IN	A,(#D8)
; Tipke, ki vrnejo 0FFh, ignoriramo
; (veliko je takih v kombinaciji s CTL/SHIFT+CTL).
FEAB	CP	#FF
FEAD	JR	Z,#FEE3
; SET UP
FEAF	CP	#FE
FEB1	JR	Z,#FF08
; BRK - ocxitno vendarle nekaj naredi?
FEB3	CP	#E0
FEB5	JR	Z,#FEF8
; Morda SHIFT+BRK? Z BASICom tega nismo mogli prebrati.
FEB7	CP	#EA
FEB9	JR	Z,#FEFA
; SCR
FEBB	CP	#B0
FEBD	JR	Z,#FF0F
; Cxe je buffer poln(?), ignoriramo tipko.
FEBF	LD	C,A
FEC0	LD	A,(#FF1A)
FEC3	CP	#08
FEC5	JR	NC,#FEE3
; Povecxamo sxtevilo cxakajocxih pritiskov v bufferju.
FEC7	INC	A
FEC8	LD	(#FF1A),A
; Shranimo tipko na lokacijo, na katero kazxe 0FF23h
FECB	LD	A,C
FECC	PUSH	HL
FECD	LD	BC,#FF22
FED0	LD	HL,(#FF23)
FED3	LD	(HL),A
; CF := 0
FED4	OR	A
; Cxe BC <= HL (torej HL >= 0FF22h), damo kazalec na zacxetek.
FED5	PUSH	HL
FED6	SBC	HL,BC
FED8	POP	HL
FED9	JR	C,#FEDE
FEDB	LD	HL,#FF1A
; Shranimo kazalec za naslednjo tipko.
FEDE	INC	HL
FEDF	LD	(#FF23),HL
FEE2	POP	HL
FEE3	POP	BC
FEE4	POP	AF
FEE5	EI
FEE6	RETI

-----

2017-05-26

*** Izpisovanje znakov na AVDC (trace iz emulatorja) ***

Izpis "navadnega" (printable) znaka na AVDC:

*** BIOS 4 (CONOUT), A = 0, BC = 47
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 16
*** IN 36 (Common input/Graphic scroll) = 0
; �akamo, dokler AVDC ready flag ni 1
*** IN 39 (AVDC status/command) = 32
; 30h = Cursor off
*** OUT 39 (AVDC status/command) = 30h
; Nastavimo znak
*** OUT 34 (Character register) = 47h
; Nastavimo atribut
*** OUT 35 (Attribute register) = 0
; 0AAh = Write at cursor address
*** OUT 39 (AVDC status/command) = AAh
*** Izpisujem G na AVDC, naslov je 582
; 35h = Cursor on
*** OUT 39 (AVDC status/command) = 35

"Izpis" CR na AVDC:

*** BIOS 4 (CONOUT), A = 0, BC = D
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 0
; 30h = Cursor off
*** OUT 39 (AVDC status/command) = 30
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 0
; �akamo, dokler AVDC ready flag ni 1
*** IN 39 (AVDC status/command) = 32
; Nastavimo cursor address na 246h
*** OUT 3C (AVDC cursor address lower) = 46h
*** OUT 3D (AVDC cursor address upper) = 2
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 16
*** IN 36 (Common input/Graphic scroll) = 16
*** IN 36 (Common input/Graphic scroll) = 0
; 35h = Cursor on
*** OUT 39 (AVDC status/command) = 35h

"Izpis" LF na AVDC (�e to ne povzro�i pomika vsebine zaslona navzgor):

*** BIOS 4 (CONOUT), A = 0, BC = A
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 16
*** IN 36 (Common input/Graphic scroll) = 0
; 30h = Cursor off
*** OUT 39 (AVDC status/command) = 30h
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 0
; �akamo, dokler AVDC ready flag ni 1
*** IN 39 (AVDC status/command) = 32
; Nastavimo cursor address na 2CAh (�e je bil prej�nji 246h, je ta za 132 - torej eno vrstico - ve�ji)
*** OUT 3C (AVDC cursor address lower) = CAh
*** OUT 3D (AVDC cursor address upper) = 2
; �akamo, dokler AVDC access flag ni 0
*** IN 36 (Common input/Graphic scroll) = 16
*** IN 36 (Common input/Graphic scroll) = 16
*** IN 36 (Common input/Graphic scroll) = 0
; 35h = Cursor on
*** OUT 39 (AVDC status/command) = 35h

Opazimo, da izpis CR-jev nastavi cursor address na:
0h = 0 (le ob inicializaciji)
1C2h = 450
246h = 582
2CAh = 714
34Eh = 846
3D2h = 978
456h = 1110
4DAh = 1242
Torej se prva vrstica za�ne �ele na naslovu 1C2h?

�e z BASIC programom
10 PRINT HEX$(INP(&H36)),: GOTO 10
gledamo vrednosti porta 36, vidimo:
* bit 6 in 7 sta vedno nastavljena
* biti 3, 2, 1 so vedno nastavljeni
* bit 0 je skoraj vedno nastavljen

Eksperimentiranje z atributi (port 35):
* bit 0 povzro�i, da znak utripa med svetlo in temno zeleno; barva se spremeni na 4 "cursor" periode, torej cursor se dvakrat pri�ge in dvakrat ugasne; �e je nastavljen �e bit 1, tudi underline utripa enako
* bit 1 deluje kot pri�akovano
* bit 2 proizvede garbage? - treba je testirati z vsemi znaki
* bit 3 ("protect") - efekt neznan
* bit 4 naredi znak �e posebej svetel - CONOUT uporablja "srednjo" zeleno, ta bit pa naredi svetlo zeleno; �e je v SET UP screen background nastavljen na reverse, pa ozadje znaka postane svetlo in je znak �rn; znaki, ki tega bita nimajo nastavljenega, pa imajo "srednje" zeleno ozadje
* bit 5 naredi �rn znak na temno zelenem ozadju (ki je temnej�e kot navadna barva znakov); �e je v SET UP screen background nastavljen na reverse, je to svetel znak na �rnem ozadju
* bit 6 naredi svetel znak na srednje zelenem ozadju; �e je v SET UP screen background nastavljen na reverse, je to srednje zelen znak na svetlem ozadju
* bit 7 naredi svetel znak na temno zelenem ozadju; �e je v SET UP screen background nastavljen na reverse, je to temno zelen znak na svetlem ozadju

Druge ugotovitve:
* Program Y.COM zahteva, da je terminal nastavljen na ANSI; tako izprazni zaslon in izpi�e "Iskra Delta" s svetlimi �rkami na temnozelenem ozadju

Program za testiranje vseh kombinacij atributov (zelo po�asen, ker BASIC nima sre�e pri pollanju; uporabi raje assembly verzijo AVDCTest.asm; ko je I% >= 5, nastanejo glitchi na zaslonu):

1 GOTO 100
10 IF (INP(&H36) AND 16) <> 0 THEN GOTO 10
20 IF (INP(&H39) AND 32) <> 0 THEN GOTO 20
30 OUT &H39, &H30
40 OUT &H34, C%
60 OUT &H35, A%
70 OUT &H39, &HAB
80 OUT &H39, &H35
90 RETURN
100 FOR I% = 0 TO 15
110 FOR J% = 0 TO 15
120 A% = I% * 16 + J%
130 C% = ASC("T"): GOSUB 10
140 C% = ASC("E"): GOSUB 10
150 C% = ASC("S"): GOSUB 10
160 C% = ASC("T"): GOSUB 10
170 NEXT J%
175 PRINT
180 NEXT I%

-----

2017-06-17

*** Real time clock ***

Ob zagonu BIOS bere z naslednjih portov, za katere je znano naslednje:

Naslov	Funkcija
A2	Packed BCD sekunde v minuti
A3	Packed BCD minute v uri
A4	Packed BCD ure v dnevu (0 do 23?)
A6	Packed BCD dan v mesecu
A7	Packed BCD mesec v letu
A9	Packed BCD zadnji dve �tevki leta
	78h do 99h so 1978 do 1999
	0 se tudi vzame kot 1978
	1 do 77h dajejo nezanesljive rezultate; za 1 se zgodi naslednje:
	* program DATE izpi�e leto kot "=3"
	* Deltin program DATUM se ne prito�uje
	* Deltin program URASET izpi�e koledar, ki se ne ujema niti s 1901 niti z 2001, se pa ujema s 1971
AB	Neznano - morda so to druge nastavitve, ki jih spreminja SET UP
AC	-||-
AE	-||-
AF	-||-

-----

2017-06-18

*** Real time clock, part deux ***

�e izvedemo ukaz v formatu "DATE mm/dd/yy hh:mm:ss", se na port A5 zapi�e vrednost 6, nato pa se ustrezne �asovne komponente zapi�ejo na zgoraj navedene porte v packed BCD formatu.

Kaj naredi GRMT20 (trace iz emulatorja)

Serijski port (LPT) inicializira takole:
1. Zapi�e 2 na port DB.
2. Bere port DB. Mi vrnemo 0.
3. Zapi�e 18h na port DB.
4. Zapi�e 5 na port DB.
5. Zapi�e 68h na port DB.
6. Zapi�e 1 na port DB.
7. Zapi�e 1Ch na port DB.
8. Zapi�e 3 na port DB.
9. Zapi�e 0C1h na port DB.

-----

2017-06-19

*** Eksperimenti z AVDC ***

BASIC program
10 PRINT HEX$(INP(&H3A)), HEX$(INP(&H3B)), HEX$(INP(&H3C)), HEX$(INP(&H3D))
izvedemo nekajkrat. Dobimo:

7E	3	6	7
E2	0	92	8
F2	2	1E	A
E2	0	AA	B
96	6	36	D
12	6	5A	1
22	B	62	2
A6	C	EE	3
2A	9	7A	5
2A	9	6	7
86	4	92	8

(Opomba: med vsakim izpisom je ena vrstica "Ok" in ena vrstica "RUN".)

�e na za�etek dodamo �e
9 FOR I% = 1 TO 10
in na konec
11 NEXT I%
in to izvedemo, dobimo:

86	5	B2	C
D2	C	36	D
2	4	BA	D
4E	B	52	0
86	5	5A	1
4E	B	46	F
86	4	DE	1
A6	B	62	2
86	E	E6	2
CA	B	6A	3

Prvi dve vrednosti sta dokaj nepredvidljivi (morda bi morali spo�tovati ready flag), zadnji dve pa ne toliko; v dveh zaporednih vrsticah se [ve�inoma] razlikujeta za to�no 132.

�e spo�tujemo �e ready in access flaga (AVDCTest.asm), dobimo naslove 456, 5E2, 76E, 8FA, A86, C12. (Vmes sta spet dve vrstici). To je v redu. �e naredimo terminal reset in potem po�enemo, dobimo 1C2, 34E, 4DA. To je tudi v redu. Toda ne vedno; lahko dobimo tudi npr. F2A in 2CA.

�e program nekoliko raz�irimo in najprej preberemo porta 3C in 3D (cursor address), nato pa 3A in 3B (screen start 1), in oboje izpi�emo, dobimo:

6EA	B0A	(To je bilo izpisano v 2. vrstici.)
876	76E	(V 5. vrstici. Vidimo, da se ta vrstica za�ne to�no 2 * 132 znakov po screen startu.)
A02	A86	(V 8. vrstici. Vidimo, da je cursor address to�no 3 * 132 znakov ve�ji kot prej, screen start pa ne.)
B8E	B8E	(!) (V 11. vrstici.)
D1A	3D2	(V 14. vrstici. Vidimo, da se ta vrstica za�ne to�no 18(!) * 132 znakov po screen startu.)
13E	36	(V 17. vrstici. Vidimo, da se ta vrstica za�ne to�no 2 * 132 znakov po screen startu. Cursor address je ni�ji, kot smo do sedaj mislili, da je minimum (1C2h); torej je za�etna vrednost 1C2h arbitrarna.)
246	7F2	(V 20. vrstici.)
3D2	D1A	(V 22. vrstici; vsebina zaslona se je pomaknila za 1 vrstico navzgor.)

(Vmes smo vrednosti shranili, da se ne bi spremenile.)

�e dvakrat zapored preberemo SS1 in si vrednosti vsaki� zapomnemo in �ele na koncu izpi�emo, dobimo npr.:

SS1 lo	SS1 hi	SS1 lo	SS1 hi
195	8	195	12
195	6	195	11
195	3	195	7
195	5	195	9

(Med vsakim parom vrstic sta "Ok" in "RUN".)

*** Nabor znakov ***

Enak je, ne glede na to, katerega izberemo v SET UP; to le pove softwaru, katere znake naj daje na zaslon.

Vsak znak je �irok 8 in visok 11 pikslov.

Znak 127 izgleda takole:

(zadnja vrstica pikslov prej�nje vrstice znakov)
********

********

********

********

********

******** (ta vrstica se ne spremeni, �e vklju�imo underline)
(prva vrstica pikslov naslednje vrstice znakov)

Prvi dve vrstici znaka 1 izgledata takole:

(zadnja vrstica pikslov prej�nje vrstice znakov)


 * * * *
  * * *
 * * * *
  * * *
 * * * *
  * * *
 * * * *
  * * *
        (ta vrstica postane "*******", �e vklju�imo underline)
(prva vrstica pikslov naslednje vrstice znakov)

*** Real time clock, part trois ***

Port A1 �teje stotinke v trenutni sekundi (packed BCD).

�e nastavimo datum na 1999-12-31, vse rollovera pravilno, le leto ostane na 99h. DATE in URASET to interpretirata kot 1999-09-14, DATUM pa kot 1999-01-01. To bo treba �e raziskati; morda obstaja kje century flag.

-----

2017-06-20

*** Eksperimenti z AVDC, part deux ***

Kot smo �e videli, BIOS ob zagonu prebere porte AB, AC, AE, AF. Z vrednostmi, ki jih prebere z AB, AE, AF, ne stori ni�esar (kmalu potem prepi�e akumulator, ne da bi ga kam shranil), vrednost od AC pa shrani na 0B5DAh. To je pomembno, ker jo potem prebere, preden inicializira AVDC; �e je vrednost enaka 51h (81), inicializacijske vrednosti (ki jih z OTIR zapi�e v inicializacijske registre AVDC) prebere z naslova 0B672h (za 80 stolpcev), druga�e pa z 0B67Ch (za 132 stolpcev - torej vse vrednosti, ki niso 81, se vzamejo kot 133 - zakaj ne 132, glej spodaj).

BIOS funkcija CONOUT to vrednost tudi prebere, ko izpisuje znake (to je trace iz emulatorja):

; Dobimo sxtevilo stolpcev + 1.
A681	LD	A,(#B5DA)
A684	LD	L,A
; ???
A685	LD	A,H
A686	AND	#C0
A688	LD	H,#00
A68A	LD	E,B
; AB je AVDC ukaz "Write at cursor address and increment address"
A68B	LD	B,#AB
A68D	JR	Z,#A69E
; Povecxamo izpisano sxt. znakov v trenutni vrstici?
A69E	LD	A,(#B5D8)
A6A1	INC	A
; Cxe je enako sxtevilu stolpcev + 1 (in je auto wraparound izkljucxen?),
; uporabimo ukaz "Write at cursor address"; kurzor se ne bo premaknil.
A6A2	CP	L
A6A3	CALL	NC,#A6D0
A6D0	LD	B,#AA

Ker smo do sedaj ob branju teh neznanih I/O portov vra�ali 0, je BIOS o�itno to interpretiral kot 0-stolp�ni zaslon z izklju�enim auto wraparoundom. Rezultat je bil, da so se vsi znaki izpisovali v isti stolpec.

Kako se zaslon scrolla?

Na Partnerju vedno velja slede�e:
* Uporablja se "row table addressing mode".
* Zato: AVDC screen start 2 je vedno 0.
* Zato: na naslovih 0 (v spominu AVDC) do 47(? - 24 vrstic je) so naslovi, ki povejo, kje se za�nejo vrstice

BIOS scrollanje opravi takole:
1. Izklopi kurzor (to naredi ve�krat med naslednjimi koraki, a to ne �kodi)
2. Popravi naslove vrstic (izra�una nove)
3. Nastavi cursor address na za�etek 24. prikazane vrstice (tiste, katere vsebina se je s spreminjanjem kazalcev premaknila navzgor in bo zdaj prazna)
4. Nastavi display pointer na cursor address + 131 (in ne 132!)
5. Nastavi character register na 32 (presledek) in attribute register na 0
6. Po�lje AVDC ukaz "write from cursor to pointer"; to napolni celotno vrstico s presledki
7. Vklopi kurzor

*** Nabor znakov, part deux ***

�e �elimo videti pove�ane znake, vtipkamo AVDCTest.asm in slede�i BASIC program (bodimo v 132-stolp�nem na�inu, ker se bolje vidi):

2 DEFINT A-Z
(Vstavi tu READ/POKE zanko)
90 FOR I = 0 TO 255
99 POKE A, 0
100 POKE A + 1, 0
110 Z = USR1(0): REM Nastavimo cursor address
120 POKE A, 48: REM Naslov prve vrstice
130 Z = USR0(0): REM Po�ljemo ukaz AB
140 POKE A, &H80: REM Ozna�imo, da je to prva v paru double height vrstic
150 Z = USR0(0)
160 POKE A, 48 + 132: REM Naslov druge vrstice
170 Z = USR0(0)
180 POKE A, &HC0: REM Ozna�imo, da je to druga v paru double height vrstic
190 Z = USR0(0)
200 POKE A, 48
210 Z = USR1(0)
220 POKE A, I
230 FOR J = 1 TO 132 * 2: REM Zapolnimo vrstici z identi�nimi znaki
240 Z = USR0(0)
250 NEXT J
260 IF INKEY$ = "" THEN GOTO 260
270 NEXT I
(Vstavi tu DATA vrstice)

-----

2017-06-21

*** Eksperimenti z AVDC, part trois ***

AVDC je v resnici konfiguriran na 26 vrstic; BIOS funkcija CONOUT uporablja le prvih 24, spodnji dve pa uporablja SET UP.

*** Nabor znakov, part trois ***

Program, s katerim si izri�emo vse znake fonta z "mre�o" za prerisovanje (zahteva AVDCTest.asm kot zgoraj):

1 DEFINT A-Z
(Vstavi tu READ/POKE zanko)
98 FOR I = 0 TO 255
99 PRINT CHR$(26): REM To je CLS za terminal Partner
100 POKE A, 0: POKE A + 1, 0: Z = USR1(0): REM Gremo na za�etek AVDC spomina
110 POKE A, 52: Z = USR0(0): REM Naslov prve vrstice
120 POKE A, &H80: Z = USR0(0): REM Prva v paru dveh dvojne �irine
130 POKE A, 52: Z = USR0(0): REM Naslov druge vrstice (enak)
140 POKE A, &HC0: Z = USR0(0): REM Druga v paru dveh dvojne �irine
141 POKE A, 52 + 132: Z = USR0(0): REM Naslov tretje vrstice
142 POKE A, &H80: Z = USR0(0): REM Prva v paru dveh dvojne �irine
143 POKE A, 52 + 132: Z = USR0(0): REM Naslov �etrte vrstice (enak)
144 POKE A, &HC0: Z = USR0(0): REM Druga v paru dveh dvojne �irine
150 POKE A, 52: Z = USR1(0): REM Gremo na naslov prve vrstice
160 FOR J = 1 TO 132
165 IF (J AND 2) = 0 THEN GOTO 177
170 POKE A, I: Z = USR0(0): REM Izpi�emo znak
175 GOTO 180
177 POKE A, 127: Z = USR0(0): REM Izpi�emo znak 127, ki je "zebra"
180 NEXT J
181 FOR J = 1 TO 132
182 POKE A, 1: REM Znak 1 je "�ahovnica"
183 IF (J AND 4) = 0 THEN POKE A + 1, 32: GOTO 185: REM Obratno ozadje
184 POKE A + 1, 0: REM Navadno ozadje
185 Z = USR0(0)
190 NEXT J
191 IF INKEY$ = "" THEN GOTO 191: REM �akamo na tipko
192 NEXT I
(Vstavi tu DATA vrstice)

-----

2017-06-23

*** Eksperimenti z AVDC, part quatre ***

�e v SET UP izberemo 80 stolpcev (in je screen background normalen), se na port 32 zapi�e vrednost 21h. �e izberemo 132 stolpcev, pa 80h.

Na pravem Partnerju BASIC stavek branje porta 32 vrne 65h za 80 stolpcev in 0C4h za 132 stolpcev. Toda SET UP naredi ve� kot le to, da zamenja med 80 in 132 stolpci, ker samo spreminjanje tega porta ne dose�e �elenega u�inka.

Kaj naredijo posamezni biti na portu 32 ("Common text attributes"):
* Bit 0 povzro�i, da se piksli vsakega znaka raztegnejo �e enkrat v desno; torej vsak znak se izri�e dvakrat, najprej tam, kjer se mora, nato pa �e enkrat 1 piksel v desno; rezultat je odebeljen znak. Izjema je najbolj desni stolpec; ta se ne podvoji, druga�e bi se znaki med seboj dotikali.
* Bit 1 ne naredi ni�esar?
* Bit 2 v 80-stolp�nem na�inu o�itno nekako vpliva na atribute in "zamenja paleto". To bo treba �e raziskati.
* Bit 3 povzro�i, da so vsi znaki enake barve kot njihovo ozadje (tudi tisti z bitom "protect" - njegova funkcija je �e vedno neznana).
* Bit 4 negira sliko.
* Biti 5, 6, 7 zamaknejo sliko v levo in povzro�ijo �udne glitche na zaslonu.

Resetiranje terminala v SET UP re�i vse te�ave - �e znamo na slepo priti do tja.

Koliko �asa trajajo delayed ukazi? Uporabljamo AVDCTest.asm in BASIC program:

1 DEFINT A-Z
(Vstavi tu READ/POKE zanko)
90 FOR I = 1 TO 20
100 POKE A, (vstavi �elen ukaz tukaj)
110 Z = USR0(0)
120 PRINT PEEK(A) + 256 * PEEK(A + 1)
130 NEXT I
(Vstavi tu DATA vrstice)

Rezultati:

Ukaz	Rezultat (najprej �tevilo iteracij, nato �tevilo pojavitev - skupaj je bilo vedno 100 meritev)
A4	5 (23), 6 (1), 7 (76)
A2	2 (19), 3 (18), 4 (1), 5 (6), 6 (1), ali 7 (54) - tu je le 99 meritev, nekje sem se zmotil
A9	0 (100) - razumljivo, ker ne dostopa do spomina
AC	5 (14), 6 (5), 7 (81)
AA	2 (10), 3 (10), 5 (8), 7 (68)
AD	2 (10), 3 (18), 4 (10), 5 (9), 6 (6), 7 (47)
AB	5 (28), 6 (3), 7 (69)
BB	TODO - to je odvisno od koli�ine podatkov
BD	TODO - to je odvisno od koli�ine podatkov

*** Real time clock, part quatre ***

Priro�nik pravi (oz. izgleda, da pravi), da RTC zavzema porte A0 do BF. Za nekatere �e vemo, kaj so, za druge pa ne. Izpi�imo njihovo vsebino nekajkrat.

Port	Prvi�	Drugi�	Tretji� (po tem, ko smo v SET UP spremenili prav vse nastavitve in jih shranili)
A0	0	90	0
A5	1	1	1
A8	F0	F0	F0
AA	FF	FF	FF
AD	F	F	F
B0	8	8	8
B1	FF	FF	FF
B2	FF	FF	FF
B3	FF	FF	FF
B4	1	1	1
B5	FF	FF	FF
B6	FF	FF	FF
B7	FF	FF	FF
B8	FF	FF	FF
B9	FF	FF	FF
BA	FF	FF	FF
BB	FF	FF	FF
BC	FF	FF	FF
BD	FF	FF	FF
BE	FF	FF	FF
BF	FF	FF	FF

Zaklju�ek: edini, ki se spreminja, je A0. Njegova vsebina je vedno X0h, kjer je X od 0 do 9. Ena mo�nost je, da �teje tiso�inke. BASIC program

1 DEFINT A-Z
10 DIM V(99)
20 FOR I = 0 TO 99
30 V(I) = INP(&HA0)
40 NEXT I
50 FOR I = 0 TO 99
60 PRINT HEX$(V(I)); " ";
70 NEXT I

izpi�e �tevila, ki nara��ajo, vendar razlika med njimi ni enakomerna. Assembly verzija (v AVDCTest.asm, �eprav ni povezano z AVDC) in BASIC program

1 DEFINT A-Z
(Vstavi READ/POKE zanko tukaj)
90 Z = USR0(0)
100 FOR I = 0 TO 255
110 PRINT HEX$(PEEK(&H7014 + I)),: REM 7014 je v tem primeru naslov bufferja
120 NEXT I
(Vstavi DATA ukaze tukaj)

pa potrdita(?) hipotezo.

-----

2017-06-28

*** Ostale CPM3.SYS verzije ***

Na trdem disku sta poleg CPM3.SYS �e dve verziji njega (z druga�nimi imeni seveda). Primerjajmo:

CPM3.SYS je "privzeta" verzija, ki je trenutno aktivna. Ob zagonu na tipkovnico (po loaderjevem copyright sporo�ilu) izpi�e:

 BNKBIOS3 SPR  FA00  0600
 BNKBIOS3 SPR  8600  3A00
 RESBDOS3 SPR  F400  0600
 BNKBDOS3 SPR  5800  2E00

 61K TPA

Ko je nalo�en in inicializira hardware, na desno stran navpi�no izpi�e version string: "Partner Gdp V 1.0 wf". Datum datoteke je 14. avgust 1989.

CPM3.GDP

Na tipkovnico izpi�e le zadnjo vrstico ("61K TPA"). Privzeti pogon je B. Version string je "Partner Gdp V 1.1 SR". Novej�a verzija? Kaj pomeni SR? Datum datoteke je 22. junij 1988.

CPM3.GSR

Izgleda enako kot CPM3.GDP (vklju�no z datumom), vendar ni. Memory dump banke 1 (takoj ob skoku na BOOT) poka�e nekaj razlik. Vse ostalo je enako.

BIOLIB.PAS (na uporabni�kih obmo�jih 0 in 5) ve�krat omenja verzijo CPM3.SYS od 9. oktobra 1987, vendar je o�itno nimamo.

-----

2017-06-29

*** Izbrisane datoteke na disku ***

Trenutno �e ni avtomatiziranega na�ina za dobivanje njih, ro�no pa se jih da dobiti nekaj.

BGRAF je "paket za poslovno grafiko". Program in priro�nik zanj sta izbrisana. Slovensko verzijo priro�nika in angle�ko verzijo programa lahko dobimo (obratno tudi?), �e po�enemo Extract.py z omogo�eno mo�nostjo shranjevanja nerabljenih blokov:

COPY /B Blok1888.dmp+Blok1889.dmp+Blok1890.dmp+Blok1891.dmp+Blok1892.dmp+Blok1893.dmp+Blok1894.dmp+Blok1895.dmp+Blok1896.dmp+Blok1897.dmp+Blok1898.dmp+Blok1899.dmp+Blok1900.dmp+Blok1901.dmp+Blok1902.dmp+Blok1903.dmp+Blok1904.dmp+Blok1905.dmp+Blok1906.dmp+Blok1907.dmp+Blok1908.dmp+Blok1909.dmp BGRAF.txt

COPY /B Blok1914.dmp+Blok1915.dmp+Blok1916.dmp+Blok1917.dmp+Blok1918.dmp+Blok1919.dmp+Blok1920.dmp+Blok1921.dmp+Blok1922.dmp+Blok1923.dmp+Blok1924.dmp BGRAF.COM

-----

2017-06-30

*** AVDC atributi ***

O�itno je barv na zaslonu ve� kot le tri odtenki zelene in �rna. Verjetno je to dejansko rezultat prikazovanja barvne slike (AVDC ima namre� barvni izhod) na monokromatskem zaslonu. �al na� Partner nima TV izhoda, tako da tega ne moremo potrditi.

Poskusimo razvrstiti atribute za ozadje (zgornji 4 biti) po svetlosti zelene, ki jo producirajo: 0, 1 (enaka - 0), 8, 9 (enaka - 64?), 4, 5 (enaka - malo ve�), 2 (nekoliko ve�), 10 (pribli�no enkrat ve�), 6 (malo ve�), 12, 13 (enaka, malo bolj turkizna?), 11, 7, 14, 15 (enaka - ve� kot 255, dodaj �e malo bele - zadnje 4 enakomerno nara��ajo).

Glede ospredja naj bi bili samo dve barvi (highlight ali ne) - treba je raziskati, ker v praksi nista, ampak je odvisno tudi od ozadja.

-----

2017-07-02

*** Testiranje I/O portov za serijski port, part quatre ***

Kaj se zgodi, ko v CCP.COM pritisnemo CTL+P in potem nekaj izpi�emo? �e je kanal LST usmerjen na napravo LPT, se kli�e BIOS funkcija LIST, ki bere statusni port. Izmeni�no preverja, ali je nastavljen bit 0 ali 2. Za slednjega vemo, da pove, ali je SIO pripravljen na nove podatke, vendar ni jasno, kaj pomeni bit 0.

-----

2017-07-04

*** Branje GDP spomina ***

GDP spomin se lahko bere po en bit naenkrat. �e pogledamo, kaj naredi podfunkcija "getpix" BIOS funkcije 37:

1. �aka, da je nastavljena GDP zastavica "ready".
2. Po�lje ukaz 0Fh.
3. �aka kot na prvem koraku.
4. Prebere najvi�ji bit porta 36 in ga negira. GDP torej vrne 1 za �rn piksel in 0 za ne-�rn (zelen) piksel.

-----

2017-07-05

*** Eksperimenti z GDP ***

Y.COM nastavi port 30 na 18h. �e ga spremenimo na 10h, se celotna slika pomakne gor in utripa; nekako to vpliva tudi na AVDC. Podobno je z 8, le da v tem primeru o�itno izri�e le vsako drugo vrstico. Z 0 je tudi tako, vendar je slika stabilna.

Pisanje na port 36 dolo�i, katera vrstica slike bo izrisana prva. Ve�ja vrednost torej sliko pomakne bolj gor. Vrstice, ki so presko�ene, se izri�ejo na koncu (vrstice se torej "rotirajo"). �e testiramo s sliko od Y.COM (prekinjenim s SHIFT+BRK - port 30 je 18h), vidimo, da so stabilne le vrednosti, deljive s 4. Pri drugih vrednostih se slika trese; ta efekt je najhuj�i, �e je ostanek enak 2. �e port 30 nastavimo na 0, so vse vrednosti stabilne.

Mo�no je, da je en na�in prepleten, drug pa ni. Kako to ugotoviti?

Na Partnerju port 2C o�itno vedno vrne 0, port 2D pa vedno 0FFh.

GDP piksli so, �e je port 30 enak 0, nekoliko vi�ji, kot so �iroki (pribli�no 1.5�). �e je port 30 enak 18h, so piksli kvadratni. (Ali se to ne kontradiktira z zgornjim? Y.COM namre� uporablja 256 vrstic - to vidimo, �e v emulatorju gledamo, kaj zapi�e v GDP RAM - ampak uporablja vrednost 18h? Toda zakaj bi piksli v vi�ji resoluciji bili ve�ji?)

�e (s portom 30 = 0) ro�no (z OUT ukazi v BASICu) nari�emo okvir okrog zaslona, vidimo, da je slika AVDC ve�ja od slike GDP - navpi�no za pribli�no 14 AVDC pikslov v vsako smer, vodoravno za pribli�no 16 AVDC pikslov v vsako smer (v 80-stolp�nem na�inu; v 132-stolp�nem pa dejansko malo manj, ker je AVDC slika o�ja).

-----

2017-07-06

*** Interrupt handlerji ***

Z BASIC programom izpisujemo spomin od 0FA84h do vklju�no 0FAB3h. Priro�nik v dodatku E na�teva interrupt handlerje, ki so "relativni na BIOS"; predpostavljamo, da to pomeni 0FA00h.

Naslov	Kazalec	Opis
FA84	FAB4
FA86	FAB4
FA88	FE3A	"flpint ; FDC interrupt vector" (glej spodaj)
FA8A	FE75	"motint ; CTC interrupt vector" (glej spodaj)
FA8C	FAB4
FA8E	FF27	"avdint ; VB" (AVDC; BIOS uporablja le vertical blanking interrupt)
FA90	FAB4
FA92	FAB4
FA94	FAB4
FA96	FAB4
FA98	FAB4
FA9A	FAB4
FA9C	FEA7	"kbdint" (podatki od tipkovnice)
FA9E	FEE8	"kbderr" (glej spodaj)
FAA0	FAB4
FAA2	FAB4
FAA4	FAB4
FAA6	FAB4
FAA8	FAB4
FAAA	FAB4
FAAC	FAB4
FAAE	FAB4
FAB0	FAB4
FAB2	FAB4

Na naslovu 0FAB4h sta, tako kot pravi priro�nik, EI in RETI.

Kaj je "kbderr"? V ZSID uporabimo ukaz "LFEE8" in dobimo:

FEE8  PUSH AF
FEE9  IN   A,D9
FEEB  LD   A,30
FEED  OUT  D9,A
FEEF  LD   A,(FF25)
FEF2  OUT  D8,A
FEF4  POP  AF
FEF5  EI
FEF6  RETI

"flpint":

FE3A  PUSH AF
FE3B  XOR  A
FE3C  LD   (FE86),A
FE3F  POP  AF
FE40  EI
FE41  RETI

"motint":

FE75  EI
FE76  RETI

Morda "mot" pomeni "motor"? Morda se ta handler nastavi le takrat, ko se izvaja FDC operacija?

*** Mi� ***

V izvorni kodi za VIGRED (datoteki MISTAB.INC in INITMIS.INC) je koda, ki inicializira in uporablja mi�. Iz nje lahko ugotovimo njen protokol. Mi� se inicializira tako, da se ji po�lje znak "c". Mi� odgovori s 60 bajti (oz. vsaj VIGRED jih toliko prebere); �e je v teh 60 bajtih niz "LOGI" (Logitech?), VIGRED po�lje znak "B" in si zapomni, da mi� obstaja. Potem periodi�no poizveduje po stanju tako, da po�lje znak "P" in prebere 5 bajtov:
* Prvi bajt pove stanje gumbov; bit 5 je levi gumb, bit 4 je srednji gumb, bit 3 je desni gumb.
* Drugi bajt v spodnjih 6 bitih vsebuje spodnjih 6 bitov razlike v X koordinati.
* Tretji bajt v spodnjih 6 bitih vsebuje zgornjih 6 bitov razlike v X koordinati (dvoji�ki komplement).
* �etrti in peti bajt naredita enako za razliko v Y koordinati. Ta nara��a navzgor.

-----

2017-07-17

*** GDP podrobnosti ***

Ura (Y.COM) ima na pravem Partnerju premer pribli�no 10 cm. �iroka je 503 pikslov, torej je gostota pribli�no 50.3 px/cm oz. 127.762 dpi.

AVDC slika je v 80-stolp�nem na�inu �iroka pribli�no 22 cm, v 132-stolp�nem pa pribli�no 21.5 cm. Visoka je pribli�no 11 cm.

Zastavica "fast write" v GDP control register 1 skrije sliko (in omogo�i hitrej�e risanje, ker se slika ne prikazuje med tem, ko jo spreminjamo).

V 256-vrsti�nem na�inu se ne da risati v vrstice 256 do 511. 256-vrsti�ni na�in uporablja spomin na prepleten na�in (3 vrstice da, 3 vrstice ne?). Brisanje slike izbri�e le trenutno vidni del, torej �e v 256-vrsti�nem na�inu bri�emo sliko, vmesne vrstice, ki so vidne le v 512-vrsti�nem na�inu, ostanejo. Brisanje vpliva le na trenutno prikazano (ne trenutno aktivno) stran.

*** Kaj se zgodi, �e beremo vse porte ***

Port	Vsebina (oboje v hex)
0-F	enako naslovu
10	7
11	0
12-13	enako naslovu
14	7
15	0
16-17	enako naslovu
18	7
19	0
1A-1B	enako naslovu
1C	7
1D	0
1E-1F	enako naslovu
(20 do 30: pri�akovano)
31	FF
(32: pri�akovano)
33-34	FF
35	3F
(36: pri�akovano)
37	FF
(38 do 3F: pri�akovano)
40-87	enako naslovu
88-8F	ne moremo testirati, ker se z menjanjem banke sesujemo; verjetno enako naslovu
90-97	enako naslovu
98-9F	enako naslovu AND 0FEh
(A0 do BF: pri�akovano)
C0-C7	3F
C8	FF
C9	64
CA	0
CB	1
CC	FF
CD	64
CE	0
CF	1
D0	F0
D1	FF
D2	0
D3	FF
D4	F0
D5	FF
D6	0
D7	FF
(D8: pri�akovano)
D9	6C
DA	FF
DB	44
DC	B0
DD	6C
DE	FF
DF	44
E0-EF	enako naslovu
F0	80
F1	8
F2	D0
F3	C1
F4	D0
F5	0
F6	80
F7	0
F8-FF	enako naslovu

*** Real time clock, part cinq ***

Port AD vrne zapisano vrednost AND 0Fh. Nastavi in prebere ga le SETUP.COM.

Kaj naredi vrednost 6, ki jo BIOS zapi�e na port A5 pred nastavljanjem ure, ni znano (vidnega u�inka ni - zagotovo ne zaustavi ure za atomarno posodobitev).

*** Testiranje I/O portov za tipkovnico, part quatre ***

Program CGRAF ob za�etku onemogo�i piskanje tipk, ob koncu pa to spet omogo�i. Kako, glede na to, da SET UP tega ne naredi, pa bi moral?

Ob za�etku CGRAF zapi�e na CRT data port bajte: 80h, 1, 88h, 1.

Ob koncu na CRT status port zapi�e 18h, 5, 68h, 4, 4Ch, 1, 18h, 3, C1h. Nato na CRT data port zapi�e 5Fh, 1, 5Fh, 1.

-----

2017-07-21

*** Eksperimentiranje z disketami ***

Z ustreznimi nastavitvami jumperjev lahko na Partnerju uporabimo single density disketnik. Partner bo disketo v njem �e vedno poskusil formatirati na svojo kapaciteto, a mu ne bo povsem uspelo, ker preprosto ni dovolj sledi. A vseeno bo dostopnih le prvih nekaj sledi, kar je dovolj, da CP/M kopira datoteke na disketo. Obstojnost take "frankensteinovske" diskete je kratka; po nekaj minutah se pojavijo te�ave pri branju in jo je treba znova formatirati.

Ukaz SHOW pravi, da ima disketa 644K prostora. �e zmno�imo dimenzije v priro�niku (146 sledi � 18 sektorjev � 256 bajtov), dobimo 657K, vzor�na disketa, ki smo jo prebrali na za�etku projekta, pa je 639K; slednje je zato, ker je moral program HxC, ki smo ga uporabili za dekodiranje KryoFluxovega streama, ugibati (toda zakaj je potem bilo formatiranih ve� sektorjev, kot bi jih moralo biti?).

-----

2017-07-25

*** GDP podrobnosti, part deux ***

�e v IDRIS nari�emo npr. "povezane linije" v emulatorju in na pravem Partnerju in jih potem izbri�emo, za njimi ostane nekaj pik - v obeh primerih, torej to ni napaka v emulatorju, ampak v programu (ki o�itno nastavi na�in risanja na XOR, ampak ne izvede popolnoma enake risarske operacije kot prej). VIGRED ima isti problem.

Pri izrisovanju besedila je razmik med znaki vedno 2 px, nikoli ve�, tudi �e je P > 1. Slede�e stvari se s tem spremenijo na bolj�e:
* version string ("Partner Gdp V 1.0 wf") ne �trli ve� izven zaslona
* naslovi menijev v VIGRED se ne prekrivajo ve� (npr. pri nastavitvah: "MENU:RAZNO")
* kalkulator v VIGRED je v celoti viden

-----

2017-08-02

*** ROM ***

�e uporabimo ROMDumper.asm in si ogledamo dump, nikjer ne vidimo pri�akovane vsebine ROMa (npr. "Delta Partner GDP", "TESTING MEMORY", itd.). Vidimo pa:

F600	IN	A,(#80)
F602	LD	HL,#E000
F605	LD	DE,#0100
F608	LD	BC,#1600
F60B	LDIR
F60D	JP	#0100

ROM o�itno del sebe (morda le to kratko rutino - okrog je �e druga koda, ki kli�e naslove v obmo�ju, ki bi lahko pripadali njemu) skopira v RAM, nalo�i CPMLDR na naslov 0E000h (morda �e preden skopira sebe), izklopi ROM, ga kopira na 100h, in za�ne izvajati.

O�itno iz softwara ni mogo�e prebrati slike ROMa. Ostaneta �e dve vpra�anji:

1. Zakaj ga vzor�na disketa (v CPMLDR) �e enkrat izklopi, �e je �e izklopljen? Morda se je na negrafi�nem Partnerju obna�al druga�e.
2. Zakaj ga CPM3.SYS na trdem disku izklopi, ko se nalo�i, �e je �e izklopljen? Ali se pri bootanju s trdega diska ne izklopi avtomati�no? Toda edini razlog, da ga ne bi, je, �e bi CPM3.SYS �e vedno uporabljal njegove funkcije. Pa jih ne, ker druga�e ne bi deloval v emulatorju.

-----

2017-08-04

*** ROM, part deux ***

CPMLDR se resda na za�etku nalo�i na naslov 0E000h. Vendar ne pozabimo, da je 1F00h bajtov dolg (to vidimo, �e pogledamo na vzor�no disketo ali hard disk in primerjamo bajte v dumpu). Ko je nalo�en, torej zaseda naslove od 0E000h do 0FEFFh. To vklju�uje 0F600h. Torej ROM morda sebe ne izklju�i, ampak po nalaganju CPMLDR sko�i na 0F600h. Torej �e vedno obstaja upanje, da lahko dobimo ROM.

*** GDP podrobnosti, part trois ***

Bit "scroll mode" na portu 30, �e je nastavljen, povzro�i, da se scrollana slika pomakne navzdol za �tevilo vrstic, dolo�eno s portom 36, vendar se vrstice, ki "padejo" z zaslona, ne prika�ejo na vrhu, ampak so tam preprosto prazne vrstice.

-----

2017-08-12

*** Diskete ***

�e si ogledamo BIOS funkcijo DRVTBL in sledimo kazalcem, pridemo do disk parameter blocka za diskete, ki je v RAM na 0FDAEh. Kaj izvemo? Da ima 18 sektorjev na sled, bloki so veliki 2K, blokov pa je 324, torej je skupna kapaciteta 648K. Dve sledi (ne bloka!) sta rezervirani - to je 9216 bajtov. SHOW poka�e 644K. Priro�nik pa:

* na 22. strani (5-4) pravi, da je kapaciteta 644K
* na 57. strani (9-1) pravi, da je kapaciteta "za uporabnika" 146 sledi po 18 sektorjev; to je 657K
* na 65. strani (9-9) pravi, da je kapaciteta 664K
* na 88. strani (A-2) pravi, da je kapaciteta 0.66 MB (to je 675.84K ali 660K z decimalnimi megabajti)

Vzor�na disketa pa je spet druge kapacitete (skupaj 693K). Kaj je torej prav? DPB se zagotovo ne moti, toda od kod pridejo ostale �tevilke in zakaj je vzor�na disketa toliko ve�ja?

-----

2017-08-14

*** Ostale CPM3.SYS verzije, part deux ***

V priro�niku je na strani 60. strani (9-4) tabela, katera verzija CPM3.SYS je za kateri model. CPM3.GDP bi naj bila verzija za zaganjanje modela WFG s hard diska, vendar v na�em primeru ni. CPM3.GSR je verzija za zaganjanje modela WFG z diskete. To pojasni, zakaj je na njej privzeti pogon B. Ne pojasni pa, kaj je razlika med na�o CPM3.GDP in CPM3.SYS.

-----

2017-08-15

*** Izbrisane datoteke na disku, part deux ***

Blok 1424: SUBMIT datoteka za namestitev VIGRED z diskete na hard disk

Bloka 1652, 1662: del priro�nika za IDRIS (pome�an z izvorno kodo za VIGRED)

Bloki 2279, 2280, 2281: del priro�nika za VIGRED

-----

2017-08-19

*** Testiranje I/O portov za tipkovnico, part cinq ***

Ugotovimo, kako se interpretirajo vrednosti, zapisane na tipkovnico (bolj ali manj - �e vedno ne vemo, kaj onemogo�i zvok tipk).

Za zvo�nik velja:
* �e sta spodnja dva bita enaka "10", je kratek pisk
* �e so spodnji trije biti enaki "100", je dolg pisk

Za lu�ke se vzameta spodnja dva bita vrednosti in velja:
* �e sta "00", se od�teje 2
* �e sta "01", se ne od�teje ni�
* �e sta "10" ali "11", se od�teje 1
Nato se biti preslikajo na lu�ke, kjer je najni�ji bit SISTEM in najvi�ji bit L5.

-----

2017-08-23

*** AVDC podrobnosti ***

Negiranje zaslona z "normal" na "reverse" povzro�i, da se zaslon za trenutek povsem negira, potem pa potemni na pribli�no polovico in se v pribli�no eni sekundi spet osvetli (hiperboli�no?). Negiranje v obratno smer povzro�i, da postane takoj svetlej�i in potem v nekoliko manj kot eni sekundi zatemni.

*** Testiranje I/O portov za tipkovnico, part cinq ***

Kot smo �e ugotovili, poslane vrednosti v glavnem dosledno spreminjajo lu�ke in aktivirajo zvo�nik. So pa izjeme:
* 0 o�itno ne naredi ni�esar
* 1 in 2 pri�geta SISTEM in ugasneta vse ostale
* pri 128 in vi�jih se najvi�ji bit o�itno ignorira (izvedejo se isti efekti kot sicer) in potem:
	* 128 nastavi razpored tipkovnice tako, da �umniki dejansko proizvedejo �rke, ki jih morajo (glej spodaj); pri tem je zanimivo, da mo�nost "keyboard type" v SET UP dejansko deluje; 95 zamenja razpored nazaj
	* 136 izklopi zvok tipk; pri tem je zanimivo, da mo�nost "key click" v SET UP dejansko deluje; 95 ga spet vklopi

*** Kode, ki jih po�ilja tipkovnica, part deux ***

Z dejanskim razporedom, ki ga aktivira vrednost 128, se spremenijo slede�e tipke:

Tipka	Brez	SHIFT	CTL	SHIFT + CTL
2	32	22	FF	FF
3	33	23	FF	E5
6	36	27	FF	FF
7	37	26	FF	26
-	2D	5F	FF	1F
=	3D	2B	8	FF
/?	2F	3F	FF	FF
Z	7A	5A	1A	19
�	7B	5B	1B	1B
�	7C	5C	1C	1C
�	7E	5E	1E	1E
�	7D	5D	1D	1D
<>	3C	3E	FF	FF
Y	79	59	19	19
,	2C	3B	FF	FF
.	2E	3A	FF	FF
�	60	40	0	0

*** GDP podrobnosti, part quatre ***

Ukaz 0Ch zapolni prikazano(!) stran zeleno, �e je izbrano pero, ali �rno, �e je izbrana radirka.

Piksli se se�tevajo samo tam, kjer se prekrivajo z AVDC ozadji; �e se prekrivajo z ospredji, se barva preprosto nastavi na tisto od GDP - ki je enaka barvi AVDC ospredja z atributom 0 (�e je ozadje zaslona �rno).

Najvi�ji bit ("graph pix input") porta 36:
* Vedno upo�teva scroll, scroll mode, in cyclic screen.
* Vrednost si zapomni, dokler ni izveden nov ukaz 0Fh na GDP.
* Vedno vrne piksel s strani, ki je izbrana za pisanje.
Skratka, vrne tisto, kar vidi oz. bi videl uporabnik, �e bi gledal stran, ki je izbrana za pisanje.

-----

2017-08-24

*** Kode, ki jih po�ilja tipkovnica, part trois ***

SET UP na na�i tipkovnici ne more spreminjati razporeda tipk, ker za QWERTZ po�lje kodo 223, ne 128 (za QWERTY pa pravilno 95). Za izklop ponavljanja tipk po�lje 127 (ekvivalentna vrednost na na�i tipkovnici �e ni znana); vklopi ga spet s 95. Zvok tipk pa vklopi s 87 in izklopi s 95(!); na na�i ga 95 vklopi, 136 pa izklopi.

-----

2017-08-25

*** AVDC podrobnosti, part deux ***

Kurzor utripa s pribli�no 93.51 udarci na minuto (en udarec = eno v�iganje). To je 1.5585 udarcev na sekundo oz. 0.6416 sekund na udarec oz. 32 framov na udarec.

-----

2017-08-26

*** VIGRED tipke ***

Tipka/tipki	Funkcija
4 num., levo	Levo
6 num., desno	Desno
8 num., gor	Gor
2 num., dol	Dol
1 num.		Dol in levo
3 num.		Dol in desno
7 num.		Gor in levo
9 num.		Gor in desno
PF1		Nastavi korak
PF2		Nastavi koordinatni sistem?
PF3		Toggla, ali je pozicija prikazana
PF4		Toggla gladkost

-----

2017-08-28

*** Kode, ki jih po�ilja tipkovnica, part quatre ***

Oz.: kode, ki jih _mi_ po�iljamo tipkovnici.

Zgodba je bolj zapletena, kot smo mislili.

Pri nas:

Kaj			Dec vr.	Bin vr.
Izklopi key click	136	10001000
Pojdi v QWERTZ		128	10000000
Default nastavitve	95	01011111

Treba bo �e raziskati.

Pri njih:

Kaj					Dec vr.	Bin vr.
QWERTY, no autorepeat, no key click	127	01111111
QWERTY, no autorepeat, key click	119	01110111
QWERTY, autorepeat, no key click	95	01011111
QWERTY, autorepeat, key click		87	01010111
QWERTZ, no autorepeat, no key click	255	11111111
QWERTZ, no autorepeat, key click	247	11110111
QWERTZ, autorepeat, no key click	223	11011111
QWERTZ, autorepeat, key click		215	11010111

Torej:
* bit 3, �e je nastavljen, izklopi key click
* bit 5, �e je nastavljen, izklopi autorepeat
* bit 7, �e je nastavljen, izbere QWERTZ, druga�e QWERTY

*** Real time clock, part six ***

Kako SET UP nastavlja PRAM porte:

AB	Zgornji 4 biti so 0 za ANSI terminal, 1 za VT-52, ali 2 za Partner. Spodnji 4 biti so nabor znakov (8 za Yugoslav, 0 za US ASCII).
AC	�tevilo stolpcev + 1 (torej 81 ali 133).
AD	Nerabljen. Zapomni si le spodnje 4 bite, kot smo �e ugotovili.
AE	Bit 0 je nastavljen, �e je screen background "reverse". Bit 1 je nastavljen za "auto wraparound". Bit 2 je nastavljen za "auto new line".
AF	Vrednost, s katero se inicializira tipkovnica. Glej zgoraj.

�e spreminjamo nabor znakov na ve�je vrednosti kot 8, dobimo zanimive efekte:

9	�rke postanejo gr�ke, toda ker gr�ka abeceda uporablja druga�en vrstni red �rk (in se ne preslikajo 1:1), to ni lahko berljivo.
A	�tevke postanejo nadpisane (superscript). Vse ostalo je ASCII.
B	�tevke postanejo podpisane (subscript). Vse ostalo je ASCII.
C	Nekatere �rke niso ve� pravilne.
D	Podobno kot C.
E	Podobno kot C in D.
F	Podobno kot C, D, in E, a �e bolj ekstremno. To smo videli na prvi dan projekta, ker je bil PRAM o�itno nastavljen na same FF bajte.

-----

2017-09-01

*** Izbrisane datoteke na disku, part trois ***

BGRAF.COM in njegov priro�nik sta sicer v enem kosu, a �e �elimo dejansko risati grafe, potrebujemo �e overlaye BGRAF.000 do BGRAF.003 (druga�e se program sesuje). Verjetno jih nekje imamo, vendar kako jih razlo�iti?

Na�li smo �e slede�e: bloki 2133 do 2146 vsebujejo fragmente priro�nika za uporabo grafi�ne knji�nice (ki ga nimamo). Ena izmed strani (na bloku 2145) je enaka kot stran 94 (D-2) iz Partnerjevega priro�nika.

-----

2017-09-02

*** Diskete, part deux ***

�e v emulatorju z BASIC programom poskusimo narediti ogromno datoteko, ki zasede celotno disketo, ugotovimo, da je prava kapaciteta diskete tista, ki jo navaja priro�nik na 57. strani (9-1), torej 146 sledi po 18 sektorjev; to je 657K.

*** Analiza zagonske diskete, part six ***

�e vedno ne vemo, zakaj je tako velika, vemo pa, da uporablja napravi CRT in VAX za izpis besedila. V emulatorju je tudi zelo nestabilna in hitro sko�i v "prepad" - kot tudi na� CPM3.SYS na trdem disku, �e mu ne bi pomagali.

*** Izbrisane datoteke na disku, part quatre ***

�e prilagodimo Extract.py, da tudi izbrisane datoteke shrani, kot da bi ne bile izbrisane (�eprav to ne gre vedno, ker so bili njihovi bloki lahko reciklirani), dobimo �e veliko datotek - med drugim tudi program TEHNOLOG, ki se zdi zanimiv.

* Bloki 1016 do 1018 so prevedena verzija tudi izbrisanega LOTO.PAS.
* Bloki 1927 do 1930 so �e en program za spreminjanje ure. Recimo mu URASET2.COM.
* Bloki 2081 do 2086 so slavni program za ustvarjanje menijev - MENUEDIT.COM.
* Bloki 2087 do 2089 so program za prikazovanje menijev - MENU.COM - ki o�itno ne uporablja istega formata kot MENUEDIT.COM?
* Blok 2094 je glavni meni (GLMENU.MNI), ki ga uporablja slednji.
* Bloki 1913, 1925, 1943, 2078, 2090, 2092 tudi izgledajo kot meniji.
* Blok 2091 je datoteka s pomo�jo za MENUEDIT.

-----

2017-09-06

*** Nedokumentirani escape sequenci ***

Uporabljamo terminal "ANSI", ki je v resnici VT100(?).

Seq	Opis
ESC ( 4	Enako kot ESC ( 0 - izbere znake za risanje �rt ipd.
ESC ( 6	Izbere gr�ko abecedo (glej "Real time clock, part six").
ESC ( 7	Izbere ASCII z nadpisanimi �tevkami (glej "Real time clock, part six").
ESC ( 8	Izbere ASCII s podpisanimi �tevkami (glej "Real time clock, part six").

Vsi ostali ESC ( sequenci (razen dokumentiranih za ostale nabore znakov) izberejo ali ASCII ali YUSCII? V vsakem primeru se upo�teva le spodnjih 7 bitov.
