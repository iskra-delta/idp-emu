;; THE COMPLETE PARTNER MODEL P ROM DISASSEMBLY
;; TOMAZ STIH, LONDON 2025

; --------------------------------------------------
; 0000: ROM Entry Point — Cold Boot Vector
; Executes on power-on or reset; interrupts remain enabled (no DI), relying on hardware reset state
0000: C3 37 01    JP init_sio_0x0137     ; Jump to SIO initialization to begin boot process

; --------------------------------------------------
; 0003: Early Boot — Stack Setup and User Prompt
; Re-entry point for failed input; sets up stack and prompts user
0003: 31 C0 FF    LD SP,0FFC0h           ; Initialize stack pointer to 0xFFC0, near top of 128KB RAM (64 bytes reserved for stack)
0006: CD B8 00    CALL newline_0x00B8    ; Output CR+LF to console via SIO for a clean terminal display

; Display prompt character
0009: 3E 2A       LD A,2Ah               ; Load ASCII '*' as boot prompt
000B: CD A9 00    CALL putchar_0x00A9    ; Send '*' to console via SIO port 0xD8

; Wait for user input
000E: CD 9F 00    CALL wait_key_0x009F   ; Poll SIO for a keypress and read character
0011: E6 DF       AND 0DFh               ; Convert to uppercase by clearing bit 5 (e.g., 'f' → 'F')
0013: FE 46       CP 46h                 ; Compare with ASCII 'F' (fast boot or floppy mode?)
0015: CA 0F 02    JP Z,main_loop_0x020F  ; If 'F', skip diagnostics and jump to main system loop
0018: 3E 3F       LD A,3Fh               ; Load ASCII '?' to indicate invalid input
001A: CD A9 00    CALL putchar_0x00A9    ; Output '?' to console
001D: 18 E4       JR 0003h               ; Loop back to reset stack and retry prompt

; --------------------------------------------------
; 001F: Padding or Reserved Space
; No execution path reaches here; likely aligns code to a 16-byte boundary or reserved for future use
001F: 00          NOP                    ; Repeated NOPs (14 bytes) — filler or placeholder
0020: 00          NOP
0021: 00          NOP
0022: 00          NOP
0023: 00          NOP
0024: 00          NOP
0025: 00          NOP
0026: 00          NOP
0027: 00          NOP
0028: 00          NOP
0029: 00          NOP
002A: 00          NOP
002B: 00          NOP

; --------------------------------------------------
; 002C: Stack Recovery Routine
; Likely a return path from an interrupt or subroutine to restore context
002C: E1          POP HL                 ; Restore HL from stack (caller’s saved address)
002D: C3 D5 19    JP unknown_0x19D5      ; Jump to a handler at 0x19D5 (system monitor or error routine?)

; --------------------------------------------------
; 0030: Memory/Debug Status Check Subroutine
; Called externally, possibly by a monitor or diagnostic tool to check system state
0030: F5          PUSH AF                ; Preserve accumulator and flags
0031: CD 18 48    CALL debug_init_0x4818 ; Initialize debug system (clear screen, set up ports?)

; Check status flags in RAM
0034: 3A 7D 3C    LD A,(3C7Dh)           ; Load status byte from RAM (disk controller state?)
0037: B7          OR A                   ; Test if zero (no activity or error)
0038: C4 C0 2C    CALL NZ,handle_status1_0x2CC0 ; If non-zero, process status (e.g., disk ready)

003B: 3A 22 3A    LD A,(3A22h)           ; Load another status byte (secondary device or flag?)
003E: B7          OR A                   ; Check for activity
003F: C4 F1 2C    CALL NZ,handle_status2_0x2CF1 ; Handle alternate condition if set

; Update a counter (boot phase or memory test iteration?)
0042: F1          POP AF                 ; Restore A and flags
0043: 21 1B 3A    LD HL,3A1Bh            ; Point to counter location in RAM
0046: 34          INC (HL)               ; Increment counter
0047: 7E          LD A,(HL)              ; Load updated value
0048: 3D          DEC A                  ; Check if it was 1 (now 0)
0049: C2 AB 2B    JP NZ,memory_counter_loop_0x2BAB ; If not zero, jump to a loop elsewhere

; Check boot state flags
004C: 21 EC 3B    LD HL,3BECh            ; Point to primary boot flag in RAM
004F: 7E          LD A,(HL)              ; Load flag value
0050: B7          OR A                   ; Test if zero (cold boot condition)
0051: C2 34 2B    JP NZ,boot_resume_0x2B34 ; If set, resume an interrupted boot process

0054: 21 4A 3B    LD HL,3B4Ah            ; Point to alternate boot flag
0057: 7E          LD A,(HL)              ; Load flag value
0058: B7          OR A                   ; Test if zero
0059: C2 34 2B    JP NZ,boot_resume_0x2B34 ; Resume boot if alternate flag is set

; Small memory copy (configuration or buffer setup?)
005C: 21 58 3D    LD HL,3D58h            ; Source address in RAM (config block?)
005F: 23          INC HL                 ; Adjust to 3D59h (skip a header byte?)
0060: 01 06 00    LD BC,0006h            ; Set length to 6 bytes
0063: 11 EC 3B    LD DE,3BECh            ; Destination: boot flag area in RAM
0066: C3 18 00    JP main_loop_0x0018    ; Intended as LDIR? Bug — jumps to 0x0018 instead of copying

; --------------------------------------------------
; 0069: Print HL as Hexadecimal (Debug Utility)
; Outputs HL as four hex digits followed by a space for debugging
0069: CD B8 00    CALL newline_0x00B8    ; Print CR+LF to start a new line
006C: 7C          LD A,H                 ; Load high byte of HL
006D: CD 79 00    CALL put_hex_0x0079    ; Convert and print H as two hex digits
0070: 7D          LD A,L                 ; Load low byte of HL
0071: CD 79 00    CALL put_hex_0x0079    ; Convert and print L as two hex digits
0074: 3E 20       LD A,20h               ; Load ASCII space
0076: C3 A9 00    JP putchar_0x00A9      ; Print space and return via putchar

; Convert Byte to Hex and Print
put_hex_0x0079:
0079: C5          PUSH BC                ; Save BC (used for temporary storage)
007A: 47          LD B,A                 ; Save original byte in B
007B: CB 2F       SRA A                  ; Shift right 4 times to isolate high nibble
007D: CB 2F       SRA A
007F: CB 2F       SRA A
0081: CB 2F       SRA A
0083: E6 0F       AND 0Fh                ; Mask to keep only high nibble (0-15)
0085: CD 90 00    CALL nibble_to_ascii_0x0090 ; Convert high nibble to ASCII and print
0088: 78          LD A,B                 ; Restore original byte
0089: E6 0F       AND 0Fh                ; Isolate low nibble
008B: CD 90 00    CALL nibble_to_ascii_0x0090 ; Convert low nibble to ASCII and print
008E: C1          POP BC                 ; Restore BC
008F: C9          RET                    ; Return to caller

; Convert Nibble to ASCII Character
nibble_to_ascii_0x0090:
0090: FE 0A       CP 0Ah                 ; Compare with 10 (digit or letter threshold)
0092: FA 99 00    JP M,nibble_is_digit_0x0099 ; If < 10, handle as digit (0-9)
0095: C6 37       ADD A,37h              ; For A-F, add 55 (e.g., 10 → 'A', 15 → 'F')
0097: 18 02       JR print_ascii_0x009B  ; Jump to print

nibble_is_digit_0x0099:
0099: C6 30       ADD A,30h              ; For 0-9, add 48 (e.g., 5 → '5')

print_ascii_0x009B:
009B: CD A9 00    CALL putchar_0x00A9    ; Output ASCII character via SIO
009E: C9          RET                    ; Return

; Wait for Keypress via SIO
wait_key_0x009F:
009F: DB D9       IN A,(0D9h)            ; Read SIO status register (port 0xD9)
00A1: CB 47       BIT 0,A                ; Check bit 0 (RX data available)
00A3: 28 FA       JR Z,wait_key_0x009F   ; Loop until data is ready in RX buffer
00A5: DB D8       IN A,(0D8h)            ; Read character from SIO data port
00A7: CB BF       RES 7,A                ; Clear bit 7 (strip parity or error flag)
00A9: F5          PUSH AF                ; Save character; shared entry point with putchar

; Output Character to SIO (putchar)
putchar_wait_0x00AA:
00AA: DB D9       IN A,(0D9h)            ; Read SIO status register
00AC: CB 57       BIT 2,A                ; Check bit 2 (TX buffer empty)
00AE: 28 FA       JR Z,putchar_wait_0x00AA ; Wait until transmitter is ready
00B0: F1          POP AF                 ; Restore character to A
00B1: D3 D8       OUT (0D8h),A           ; Send character to SIO data port
00B3: C9          RET                    ; Return to caller

; Print Newline (CR + LF)
newline_0x00B4:                        ; Unused alias? Overlaps with next routine
00B4: 3E 20       LD A,20h               ; Load space character (fallback or typo?)
00B6: 18 F1       JR putchar_0x00A9      ; Jump to putchar (incomplete routine?)

newline_0x00B8:
00B8: 3E 0A       LD A,0Ah               ; Load ASCII LF (line feed)
00BA: CD A9 00    CALL putchar_0x00A9    ; Output LF to console
00BD: 3E 0D       LD A,0Dh               ; Load ASCII CR (carriage return)
00BF: 18 E8       JR putchar_0x00A9      ; Output CR and return via putchar

; --------------------------------------------------
; 00C1: Memory Test Routine
; Tests 64KB of RAM with two pattern passes (0x00/0xFF, 0x55/0xAA)
mem_test_0x00C1:
00C1: 21 A8 01    LD HL,01A8h            ; Point to "TESTING MEMORY ..." string in ROM
00C4: CD 86 01    CALL print_string_0x0186 ; Display test start message via SIO

00C7: 21 00 20    LD HL,2000h            ; Start of RAM test region (32KB into 128KB RAM)
00CA: 01 80 FF    LD BC,0FF80h           ; Length = 0xFF80 bytes (~64KB, full RAM minus stack/reserved)
00CD: 16 02       LD D,02h               ; Number of test passes (2 patterns)
00CF: 3E 00       LD A,00h               ; First pattern = 0x00
mem_test_loop_0x00D1:
00D1: D5          PUSH DE                ; Save pass counter
00D2: F5          PUSH AF                ; Save current pattern
00D3: CD DE 00    CALL write_verify_0x00DE ; Write pattern and verify RAM contents
00D6: F1          POP AF                 ; Restore pattern
00D7: D1          POP DE                 ; Restore pass counter
00D8: C6 55       ADD A,55h              ; Next pattern = prev + 0x55 (0x00 → 0x55)
00DA: 15          DEC D                  ; Decrement pass counter
00DB: 20 F4       JR NZ,mem_test_loop_0x00D1 ; Repeat for second pattern (0x55/0xAA)
00DD: C9          RET                    ; Memory test complete; RAM is functional

; Write and Verify Pattern Pair
write_verify_0x00DE:
00DE: CD EF 00    CALL write_pattern_0x00EF ; Fill RAM with pattern and its complement
00E1: D3 90       OUT (90h),A            ; Output pattern to port 0x90 (status LED or test signal?)
00E3: CD EF 00    CALL write_pattern_0x00EF ; Write again (redundant? or phase 2 of test?)
00E6: CD 02 01    CALL verify_pattern_0x0102 ; Verify RAM matches pattern/complement
00E9: D3 88       OUT (88h),A            ; Output verify result to port 0x88 (success/fail indicator?)
00EB: CD 02 01    CALL verify_pattern_0x0102 ; Verify again (consistency check?)
00EE: C9          RET                    ; Return to test loop

; Write Pattern and Complement to RAM
write_pattern_0x00EF:
00EF: F5          PUSH AF                ; Save pattern
00F0: E5          PUSH HL                ; Save start address
00F1: 57          LD D,A                 ; D = pattern (e.g., 0x00)
00F2: 2F          CPL                    ; A = complement (e.g., 0xFF)
00F3: 5F          LD E,A                 ; E = complement
write_loop_0x00F4:
00F4: 72          LD (HL),D              ; Write pattern to current address
00F5: 23          INC HL                 ; Next address
00F6: 73          LD (HL),E              ; Write complement to next address
00F7: 23          INC HL                 ; Move to next pair
00F8: E5          PUSH HL                ; Save current position
00F9: B7          OR A                   ; Clear carry for subtraction
00FA: ED 42       SBC HL,BC              ; Check if HL >= end address (BC = end)
00FC: E1          POP HL                 ; Restore HL
00FD: 38 F5       JR C,write_loop_0x00F4 ; Continue if more to write
00FF: E1          POP HL                 ; Restore start address
0100: F1          POP AF                 ; Restore pattern
0101: C9          RET                    ; Done filling RAM

; Verify Pattern and Complement in RAM
verify_pattern_0x0102:
0102: E5          PUSH HL                ; Save start address
0103: F5          PUSH AF                ; Save pattern
0104: 57          LD D,A                 ; D = expected pattern
0105: 2F          CPL                    ; A = expected complement
0106: 5F          LD E,A                 ; E = complement
verify_loop_0x0107:
0107: 7E          LD A,(HL)              ; Read byte from RAM
0108: BA          CP D                   ; Compare with pattern
0109: 20 10       JR NZ,verify_fail_0x011B ; Jump to error if mismatch
010B: 23          INC HL                 ; Next address
010C: 7E          LD A,(HL)              ; Read next byte
010D: BB          CP E                   ; Compare with complement
010E: 20 0B       JR NZ,verify_fail_0x011B ; Jump to error if mismatch
0110: 23          INC HL                 ; Move to next pair
0111: E5          PUSH HL                ; Save current HL
0112: B7          OR A                   ; Clear carry
0113: ED 42       SBC HL,BC              ; Check if end reached
0115: E1          POP HL                 ; Restore HL
0116: 38 EF       JR C,verify_loop_0x0107 ; Continue if more to verify
0118: F1          POP AF                 ; Restore pattern
0119: E1          POP HL                 ; Restore start address
011A: C9          RET                    ; Verification successful

; Handle Memory Verification Failure
verify_fail_0x011B:
011B: 21 24 01    LD HL,error_string_0x0124 ; Point to "MEMORY ERROR!!" string in ROM
011E: CD 86 01    CALL print_string_0x0186 ; Display error message via SIO
0121: C3 03 00    JP mem_test_0x00C1     ; Restart memory test (soft reset after failure)

; Error Message String
error_string_0x0124:
0124: 0D          .db 0Dh                ; CR (carriage return)
0125: 0A          .db 0Ah                ; LF (line feed)
0126: 4D          .db 'M'                ; "MEMORY ERROR!!" in YUSCII encoding
0127: 45          .db 'E'
0128: 4D          .db 'M'
0129: 4F          .db 'O'
012A: 52          .db 'R'
012B: 59          .db 'Y'
012C: 20          .db ' '
012D: 45          .db 'E'
012E: 52          .db 'R'
012F: 52          .db 'R'
0130: 4F          .db 'O'
0131: 52          .db 'R'
0132: 20          .db ' '
0133: 21          .db '!'
0134: 21          .db '!'
0135: 00          .db 00h                ; Null terminator for string

; --------------------------------------------------
; 0137: SIO Initialization Routine
; Configures four SIO channels (two chips, A/B ports each) for serial I/O
init_sio_0x0137:
0137: 0E D9       LD C,0D9h              ; SIO 1, Port B control register
0139: 21 8F 01    LD HL,sio_init_block_0x018F ; Point to 7-byte configuration block
013C: 06 07       LD B,07h               ; 7 bytes to write
013E: ED B3       OTIR                   ; Output init block to SIO 1B (port 0xD9)

0141: 0E DB       LD C,0DBh              ; SIO 1, Port A control register
0144: 21 8F 01    LD HL,sio_init_block_0x018F ; Reuse same init block
0146: 06 07       LD B,07h               ; 7 bytes
0148: ED B3       OTIR                   ; Configure SIO 1A (port 0xDB)

014A: 0E E1       LD C,0E1h              ; SIO 2, Port B control register
014D: 21 8F 01    LD HL,sio_init_block_0x018F
014F: 06 07       LD B,07h
0151: ED B3       OTIR                   ; Configure SIO 2B (port 0xE1)

0153: 0E E3       LD C,0E3h              ; SIO 2, Port A control register
0156: 21 8F 01    LD HL,sio_init_block_0x018F
0158: 06 07       LD B,07h
015A: ED B3       OTIR                   ; Configure SIO 2A (port 0xE3)

; Continue Boot Process
015B: 31 C0 FF    LD SP,0FFC0h           ; Reset stack pointer to 0xFFC0 (redundant if from 0000)
015E: CD C1 00    CALL mem_test_0x00C1   ; Run RAM test with patterns 0x00 and 0x55
0161: 21 96 01    LD HL,banner_string_0x0196 ; Point to "DELTA PARTNER /F" banner string
0164: CD 86 01    CALL print_string_0x0186 ; Display welcome message via SIO

; Prepare for System Handoff
0167: 2A FE 07    LD HL,(07FEh)          ; Load jump target from RAM vector at 0x07FE (CP/M or monitor entry?)
016A: 3E 04       LD A,04h               ; Load ASCII EOT (end of transmission)
016C: CD A9 00    CALL putchar_0x00A9    ; Send EOT to signal end of ROM initialization
016F: DD 2A FC 07 LD IX,(07FCh)          ; Load IX with system vector from 0x07FC (indirect jump target)

; Output System Vector to Hardware
0173: 3A FC 07    LD A,(07FCh)           ; Load low byte of vector
0176: D3 AE       OUT (0AEh),A           ; Send to port 0xAE (disk controller or CTC?)
0178: 3A FD 07    LD A,(07FDh)           ; Load high byte of vector
017B: D3 AF       OUT (0AFh),A           ; Send to port 0xAF (paired with 0xAE)

; Final Initialization and Jump
017D: CD 00 02    CALL system_entry_0x0200 ; Set up interrupt mode and hardware
0180: CD 03 02    CALL system_entry2_0x0203 ; Additional init (redundant? calls RET)
0183: C3 0F 02    JP main_loop_0x020F    ; Enter main system loop (monitor or OS)

; --------------------------------------------------
; 0186: Print Null-Terminated String
; Outputs a string from (HL) until a 0x00 byte is encountered
print_string_0x0186:
0186: 7E          LD A,(HL)              ; Load next character from string
0187: B7          OR A                   ; Test for null terminator (0x00)
0188: C8          RET Z                  ; Return if end of string
0189: CD A9 00    CALL putchar_0x00A9    ; Output character via SIO
018C: 23          INC HL                 ; Advance to next character
018D: 18 F7       JR print_string_0x0186 ; Loop until null found

; SIO Initialization Data Block
; Configures SIO channels for 8-bit async communication, no parity, 1 stop bit
sio_init_block_0x018F:
018F: 18          .db 18h                ; WR0: Select WR4, reset channel
0190: 04          .db 04h                ; WR4: x16 clock mode, 1 stop bit, no parity
0191: 44          .db 44h                ; WR3: Enable RX, 8-bit characters
0192: 03          .db 03h                ; WR1: Enable RX interrupt
0193: C1          .db C1h                ; WR5: Enable TX, 8-bit characters
0194: 05          .db 05h                ; WR2: RTS on, no TX interrupt
0195: 68          .db 68h                ; WR14: Reset error latches, enable channel

; Welcome Banner String
banner_string_0x0196:
0196: 1C          .db 1Ch                ; Non-printable (clear screen or control code?)
0197: 44          .db 'D'                ; "DELTA PARTNER /F" — system identifier
0198: 45          .db 'E'
0199: 4C          .db 'L'
019A: 54          .db 'T'
019B: 41          .db 'A'
019C: 20          .db ' '
019D: 50          .db 'P'
019E: 41          .db 'A'
019F: 52          .db 'R'
01A0: 54          .db 'T'
01A1: 4E          .db 'N'
01A2: 45          .db 'E'
01A3: 52          .db 'R'
01A4: 20          .db ' '
01A5: 2F          .db '/'
01A6: 46          .db 'F'
01A7: 00          .db 00h                ; Null terminator

; Memory Test Start Message
01A8: 0D          .db 0Dh                ; CR
01A9: 0A          .db 0Ah                ; LF
01AA: 0A          .db 0Ah                ; Extra LF for spacing
01AB: 54          .db 'T'                ; "TESTING MEMORY ..."
01AC: 45          .db 'E'
01AD: 53          .db 'S'
01AE: 54          .db 'T'
01AF: 49          .db 'I'
01B0: 4E          .db 'N'
01B1: 47          .db 'G'
01B2: 20          .db ' '
01B3: 4D          .db 'M'
01B4: 45          .db 'E'
01B5: 4D          .db 'M'
01B6: 4F          .db 'O'
01B7: 52          .db 'R'
01B8: 59          .db 'Y'
01B9: 20          .db ' '
01BA: 2E          .db '.'
01BB: 2E          .db '.'
01BC: 2E          .db '.'
01BD: 20          .db ' '
01BE: 00          .db 00h                ; Null terminator

; Partial Error Message or Fragment
01BF: 01          .db 01h                ; Start of something? (vector or typo)
01C0: 4E          .db 'N'                ; "No "
01C1: 6F          .db 'o'
01C2: 20          .db ' '
01C3: 00          .db 00h                ; Premature null (incomplete string?)

; Another Message Fragment
01C4: 20          .db ' '                ; " Failsafe RET:"
01C5: 46          .db 'F'
01C6: 61          .db 'a'
01C7: 74          .db 't'
01C8: 58          .db 'X'                ; Typo? Should be 'a' (0x61)?
01C9: 52          .db 'R'
01CA: 45          .db 'E'
01CB: 54          .db 'T'
01CC: 3A          .db ':'
01CD: 09          .db 09h                ; TAB
01CE: 52          .db 'R'
01CF: 45          .db 'E'
01D0: 54          .db 'T'
01D1: 0D          .db 0Dh                ; CR
01D2: 0A          .db 0Ah                ; LF
01D3: 0D          .db 0Dh                ; Extra CR
01D4: 0A          .db 0Ah                ; Extra LF

; Odd Repeated String (Padding or Debug?)
01D5: 09          .db 09h                ; TAB or control code
01D6: 6E          .db 'n'                ; "nop ! nop ! nop ! nop ! op ! op"
01D7: 6F          .db 'o'
01D8: 70          .db 'p'
01D9: 20          .db ' '
01DA: 21          .db '!'
01DB: 20          .db ' '
01DC: 6E          .db 'n'
01DD: 6F          .db 'o'
01DE: 70          .db 'p'
01DF: 20          .db ' '
01E0: 21          .db '!'
01E1: 6E          .db 'n'
01E2: 6F          .db 'o'
01E3: 70          .db 'p'
01E4: 20          .db ' '
01E5: 21          .db '!'
01E6: 6E          .db 'n'
01E7: 6F          .db 'o'
01E8: 70          .db 'p'
01E9: 20          .db ' '
01EA: 21          .db '!'
01EB: 6F          .db 'o'
01EC: 70          .db 'p'
01ED: 20          .db ' '
01EE: 21          .db '!'
01EF: 6F          .db 'o'
01F0: 70          .db 'p'
01F1: 0D          .db 0Dh                ; CR
01F2: 0A          .db 0Ah                ; LF

; Decorative ASCII Border
01F3: 3B          .db ';'                ; "------------"
01F4: 2D          .db '-'
01F5: 2D          .db '-'
01F6: 2D          .db '-'
01F7: 2D          .db '-'
01F8: 2D          .db '-'
01F9: 2D          .db '-'
01FA: 2D          .db '-'
01FB: 2D          .db '-'
01FC: 2D          .db '-'
01FD: 2D          .db '-'
01FE: 2D          .db '-'
01FF: 2D          .db '-'

; --------------------------------------------------
; 0200: Interrupt/Trap Vector Table
; Defines jump targets for IM2 interrupt mode
system_entry_0x0200:
0200: C3 06 04    JP reset_handler_0x0406 ; Vector 0: System reset or initialization

system_entry2_0x0203:
0203: C3 12 02    JP ret_0x0212          ; Vector 1: Simple return (placeholder?)
0206: C3 12 02    JP ret_0x0212          ; Vector 2: Return
0209: C3 12 02    JP ret_0x0212          ; Vector 3: Return
020C: C3 12 02    JP ret_0x0212          ; Vector 4: Return

main_loop_0x020F:
020F: C3 1E 02    JP dma_int_handler_0x021E ; Vector 5: DMA interrupt handler

; Default Interrupt Return
ret_0x0212:
0212: C9          RET                    ; Return from interrupt (IRET equivalent)

; Unused or Corrupted Code?
0213: 00          NOP                    ; Filler bytes
0214: 00          NOP
0215: 00          NOP
0216: 00          NOP
0217: 00          NOP
0218: 3B          DEC SP                 ; Start of vector table data? (misaligned)
0219: 05          DEC B
021A: 99          SBC A,C
021B: 05          DEC B
021C: 3B          DEC SP
021D: 05          DEC B

; --------------------------------------------------
; 021E: DMA Interrupt Handler
; Handles DMA operations, likely for disk I/O
dma_int_handler_0x021E:
021E: 31 35 DF    LD SP,0DF35h           ; Set stack pointer to DMA workspace in RAM
0221: 3E 03       LD A,03h               ; Load DMA/CTC control value (mode select?)
0223: D3 CA       OUT (0CAh),A           ; Configure DMA or CTC channel (port 0xCA)

0225: 11 07 03    LD DE,dma_msg_reading_0x0307 ; Point to "reading system tracks" message
0228: CD E0 03    CALL print_string_dollar_0x03E0 ; Print $-terminated string

022B: 3E 00       LD A,00h               ; Clear value (reset flag?)
022D: 32 01 DF    LD (0DF01h),A          ; Store to DMA status/control register

0230: CD 40 04    CALL dma_action_1_0x0440 ; Perform initial DMA action (setup?)
0233: 3E 01       LD A,01h               ; Set flag to 1 (enable transfer?)
0235: 32 01 DF    LD (0DF01h),A          ; Update DMA control register

0238: CD 40 04    CALL dma_action_1_0x0440 ; Execute DMA action again (second phase?)

023B: 3E 0A       LD A,0Ah               ; Load transfer count (10 blocks?)
023D: 32 00 DF    LD (0DF00h),A          ; Set DMA transfer counter

; Configure DMA Controller
0240: 3E 01       LD A,01h               ; Enable DMA bit
0242: 32 03 DF    LD (0DF03h),A          ; Write to DMA control register

0245: 3E 00       LD A,00h               ; Clear flags or reset state
0247: 32 02 DF    LD (0DF02h),A          ; Write to DMA status register

024A: 21 3F 05    LD HL,dma_config_1_0x053F ; Point to first DMA config block
024D: CD 5E 04    CALL dma_write_config_0x045E ; Write 17-byte config to DMA controller
0250: CA 69 02    JP Z,dma_altpath_0x0269 ; If config failed (Z set), try alternate path

; Check DMA Completion
0253: 3A 00 DF    LD A,(0DF00h)          ; Read transfer counter
0256: B7          OR A                   ; Test if zero (transfer done?)
0257: CA AD 02    JP Z,dma_status_handler_0x02AD ; If zero, handle status/errors

025A: 3D          DEC A                  ; Decrement counter
025B: 32 00 DF    LD (0DF00h),A          ; Store updated count

025E: 3E 02       LD A,02h               ; Set next DMA mode or flag
0260: 32 02 DF    LD (0DF02h),A          ; Update DMA status register
0263: CD AE 04    CALL dma_check_irq_0x04AE ; Validate DMA interrupt status
0266: C3 40 02    JP 0240h              ; Loop back to continue DMA process

; Alternate DMA Path (Retry Logic)
dma_altpath_0x0269:
0269: 3E 0A       LD A,0Ah               ; Reset counter to 10 (retry limit?)
026B: 32 00 DF    LD (0DF00h),A          ; Store in DMA counter

dma_retry_loop_0x026E:
026E: 3E 01       LD A,01h               ; Enable DMA again
0270: 32 03 DF    LD (0DF03h),A          ; Write to control register
0273: 3E 01       LD A,01h               ; Alternate mode or flag
0275: 32 02 DF    LD (0DF02h),A          ; Update status register

0278: 21 50 05    LD HL,dma_config_2_0x0550 ; Point to second DMA config block
027B: CD 5E 04    CALL dma_write_config_0x045E ; Write alternate 17-byte config
027E: CA 97 02    JP Z,dma_romscan_0x0297 ; If config failed, scan for ROM boot

0281: 3A 00 DF    LD A,(0DF00h)          ; Read DMA counter
0284: B7          OR A                   ; Test if zero
0285: CA AD 02    JP Z,dma_status_handler_0x02AD ; If zero, handle status

0288: 3D          DEC A                  ; Decrement counter
0289: 32 00 DF    LD (0DF00h),A          ; Store updated value

028C: 3E 02       LD A,02h               ; Set next mode
028E: 32 02 DF    LD (0DF02h),A          ; Update status
0291: CD AE 04    CALL dma_check_irq_0x04AE ; Check interrupt status
0294: C3 6E 02    JP dma_retry_loop_0x026E ; Retry DMA operation

; Fallback: Scan for Bootable ROM
dma_romscan_0x0297:
0297: 3A 00 E0    LD A,(0E000h)          ; Check address 0xE000 for boot signature
029A: FE C3       CP 0C3h                ; Compare with JP opcode (0xC3)
029C: CA 00 F6    JP Z,boot_from_rom_0xF600 ; If JP found, boot from ROM at 0xF600

029F: FE 31       CP 31h                 ; Check for LD SP,nn opcode (alternate reset vector)
02A1: CA 00 F6    JP Z,boot_from_rom_0xF600 ; If valid, jump to ROM

02A4: 11 72 03    LD DE,error_reading_0x0372 ; Point to "not reached" error message
02A7: CD E0 03    CALL print_string_dollar_0x03E0 ; Display error
02AA: C3 03 00    JP mem_test_0x00C1     ; Soft reset by restarting memory test

; DMA Status/Error Handler
dma_status_handler_0x02AD:
02AD: 3A 08 DF    LD A,(0DF08h)          ; Read DMA status/error register
02B0: E6 7F       AND 7Fh                ; Mask out bit 7 (ignore reserved/status bit)
02B2: C4 E0 02    CALL NZ,dma_err_bit7_0x02E0 ; If any bits set, handle general error

02B5: 3A 08 DF    LD A,(0DF08h)          ; Re-read status
02B8: E6 20       AND 20h                ; Check bit 5 (sector not found?)
02BA: C4 E4 02    CALL NZ,dma_err_bit5_0x02E4 ; Handle sector not found error

02BD: 3A 08 DF    LD A,(0DF08h)          ; Re-read
02C0: E6 04       AND 04h                ; Check bit 2 (data CRC error?)
02C2: C4 EB 02    CALL NZ,dma_err_bit2_0x02EB ; Handle CRC error

02C5: 3A 08 DF    LD A,(0DF08h)          ; Re-read
02C8: E6 10       AND 10h                ; Check bit 4 (write protect?)
02CA: C4 F9 02    CALL NZ,dma_err_bit4_0x02F9 ; Handle write protect or misc error

02CD: 3A 08 DF    LD A,(0DF08h)          ; Re-read
02D0: E6 01       AND 01h                ; Check bit 0 (ID CRC error?)
02D2: C4 F2 02    CALL NZ,dma_err_bit0_0x02F2 ; Handle ID field error

02D5: 3A 0C DF    LD A,(0DF0Ch)          ; Read DMA end code or status
02D8: FE 12       CP 12h                 ; Compare with expected completion value
02DA: C4 00 03    CALL NZ,dma_unexpected_0x0300 ; If unexpected, handle anomaly

02DD: C3 03 00    JP mem_test_0x00C1     ; Restart system (soft reboot)

; DMA Error Handlers
dma_err_bit7_0x02E0:
02E0: CD A2 03    CALL dma_show_regstate_0x03A2 ; Display DMA/FDC registers for debugging
02E3: C9          RET                    ; Return to status handler

dma_err_bit5_0x02E4:
02E4: 11 1F 03    LD DE,msg_sector_not_found_0x031F ; Point to "CRC error" message (mislabeled?)
02E7: CD E0 03    CALL print_string_dollar_0x03E0 ; Display error
02EA: C9          RET

dma_err_bit2_0x02EB:
02EB: 11 2B 03    LD DE,msg_crc_error_0x032B ; Point to "SECTOR not found" message (mislabeled?)
02EE: CD E0 03    CALL print_string_dollar_0x03E0 ; Display error
02F1: C9          RET

dma_err_bit0_0x02F2:
02F2: 11 3E 03    LD DE,msg_idcrc_error_0x033E ; Point to "Missing address mark" message
02F5: CD E0 03    CALL print_string_dollar_0x03E0 ; Display error
02F8: C9          RET

dma_err_bit4_0x02F9:
02F9: 11 55 03    LD DE,msg_protect_or_misc_0x0355 ; Point to "Overrun" message (mislabeled?)
02FC: CD E0 03    CALL print_string_dollar_0x03E0 ; Display error
02FF: C9          RET

dma_unexpected_0x0300:
0300: 11 60 03    LD DE,msg_unknown_error_0x0360 ; Point to "not reached" message
0303: CD E0 03    CALL print_string_dollar_0x03E0 ; Display unexpected state error
0306: C9          RET

; DMA Error Messages
msg_reading_0x0307:
0307:             .db "reading system tracks$" ; $-terminated string
; Bytes: 0x0A 0x0D "reading system tracks" 0x24

msg_sector_not_found_0x031F:
031F:             .db "CRC error$"       ; Should be "sector not found"? Mismatch with label

msg_crc_error_0x032B:
032B:             .db "SECTOR not found$" ; Should be "CRC error"? Mismatch with label

msg_idcrc_error_0x033E:
033E:             .db "Missing address mark$" ; ID field CRC error message

msg_protect_or_misc_0x0355:
0355:             .db "Overrun$"          ; Should be "write protect"? Mismatch with label

msg_unknown_error_0x0360:
0360:             .db "not reached$"      ; Unexpected DMA state message

; Fallback Error Message (from ROM scan)
error_reading_0x0372:
0372:             .db "not reached$"      ; Reused from 0x0360 (lazy duplicate?)

; --------------------------------------------------
; 03A2: Dump Floppy Controller Registers
; Debug routine to display FDC/DMA state
dma_show_regstate_0x03A2:
03A2: CD E0 03    CALL print_string_dollar_0x03E0 ; Print error message from DE (set by caller)
03A5: 3A 0B DF    LD A,(0DF0Bh)          ; Load FDC register 1 (status or data?)
03A8: CD BA 03    CALL put_hex_byte_0x03BA ; Print as two hex digits

03AB: 0E 20       LD C,20h               ; Load ASCII space
03AD: CD D5 03    CALL wait_and_putchar_0x03D5 ; Output space separator

03B0: 3A 0C DF    LD A,(0DF0Ch)          ; Load FDC register 2 (end code?)
03B3: CD BA 03    CALL put_hex_byte_0x03BA ; Print as hex

03B6: C9          RET                    ; Return to error handler

; Convert Byte to Hex and Print
put_hex_byte_0x03BA:
03BA: 47          LD B,A                 ; Save original byte in B
03BB: 0F          RRCA                   ; Rotate right 4 times to get high nibble
03BC: 0F          RRCA
03BD: 0F          RRCA
03BE: 0F          RRCA
03BF: E6 0F       AND 0Fh                ; Mask to isolate high nibble
03C1: CD C7 03    CALL hex_nibble_to_ascii_0x03C7 ; Convert and print high nibble

03C4: 78          LD A,B                 ; Restore original byte
03C5: E6 0F       AND 0Fh                ; Isolate low nibble

hex_nibble_to_ascii_0x03C7:
03C7: FE 0A       CP 0Ah                 ; Compare with 10 (digit or letter?)
03C9: FA CE 03    JP M,putchar_ascii_0x03CE ; If < 10, it’s a digit
03CC: C6 07       ADD A,07h              ; For A-F, add 7 (e.g., 10 → 'A')

putchar_ascii_0x03CE:
03CE: C6 30       ADD A,30h              ; Add 48 to convert to ASCII (0-9 or A-F)
03D0: 4F          LD C,A                 ; Save ASCII char in C
03D1: CD D5 03    CALL wait_and_putchar_0x03D5 ; Output character
03D4: C9          RET                    ; Return

; Wait and Output Character via SIO
wait_and_putchar_0x03D5:
03D5: DB D9       IN A,(0D9h)            ; Read SIO status register
03D7: E6 04       AND 04h                ; Check bit 2 (TX buffer empty, mislabeled as 04h)
03D9: CA D5 03    JP Z,wait_and_putchar_0x03D5 ; Wait until ready
03threeC: 79          LD A,C                 ; Load character from C
03DD: D3 D8       OUT (0D8h),A           ; Send to SIO data port
03DF: C9          RET                    ; Return

; Print $-Terminated String
print_string_dollar_0x03E0:
03E0: 1A          LD A,(DE)              ; Load next character from string
03E1: FE 24       CP 24h                 ; Check for '$' terminator
03E3: C8          RET Z                  ; Return if end of string
03E4: 4F          LD C,A                 ; Save char in C
03E5: CD D5 03    CALL wait_and_putchar_0x03D5 ; Output character
03E8: 13          INC DE                 ; Next character
03E9: C3 E0 03    JP print_string_dollar_0x03E0 ; Loop until '$'

; Send Command to DMA/FDC
dma_send_cmd_0x03EC:
03EC: F5          PUSH AF                ; Save command byte

dma_wait_ready_0x03ED:
03ED: DB F0       IN A,(0F0h)            ; Read FDC status port
03EF: E6 C0       AND 0C0h               ; Mask bits 7 and 6 (busy/ready flags)
03F1: FE 80       CP 80h                 ; Wait for bit 7 clear, bit 6 set (ready)
03F3: C2 ED 03    JP NZ,dma_wait_ready_0x03ED ; Loop until ready

03F6: F1          POP AF                 ; Restore command byte
03F7: D3 F1       OUT (0F1h),A           ; Send command to FDC command port
03F9: C9          RET                    ; Return

; Read Data from DMA/FDC
dma_read_result_0x03FA:
03FA: DB F0       IN A,(0F0h)            ; Read FDC status
03FC: E6 C0       AND 0C0h               ; Check bits 7 and 6
03FE: FE C0       CP 0C0h                ; Wait for 11xxxxxx (data ready)
0400: C2 FA 03    JP NZ,dma_read_result_0x03FA ; Loop until ready

0403: DB F1       IN A,(0F1h)            ; Read data byte from FDC
0405: C9          RET                    ; Return with result in A

; --------------------------------------------------
; 0406: Configure IM2 Interrupt Mode
; Sets up interrupt vector table and hardware for IM2
setup_im2_0x0406:
0406: F3          DI                     ; Disable interrupts during setup
0407: ED 5E       IM 2                   ; Switch Z80 to Interrupt Mode 2
0409: 21 18 02    LD HL,0218h            ; Base address of IM2 vector table (0x0218)

040C: 7D          LD A,L                 ; Load low byte (0x18)
040D: D3 E8       OUT (0E8h),A           ; Set FDC IM2 vector low byte
040F: D3 C8       OUT (0C8h),A           ; Set CTC vector base (channel 0?)

0411: 7C          LD A,H                 ; Load high byte (0x02)
0412: ED 47       LD I,A                 ; Set I register to 0x02 (table at 0x0200-0x02FF)
0414: FB          EI                     ; Enable interrupts

; Send FDC Command Sequence
0415: 76          HALT                   ; Wait for first interrupt
0416: 3E 08       LD A,08h               ; Command 0x08 (Sense Interrupt Status)
0418: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

041B: CD FA 03    CALL dma_read_result_0x03FA ; Read status byte 1
041E: CD FA 03    CALL dma_read_result_0x03FA ; Read status byte 2

0421: 3E 03       LD A,03h               ; Command 0x03 (Specify?)
0423: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

; Build and Send Complex Command
0426: 3E 0E       LD A,0Eh               ; Base value for command
0428: E6 0F       AND 0Fh                ; Isolate low nibble (0x0E)
042A: 07          RLCA                   ; Shift left 4 times
042B: 07          RLCA
042C: 07          RLCA
042D: 07          RLCA                   ; Move to high nibble (0xE0)
042E: 47          LD B,A                 ; Save shifted value
042F: 3E 0E       LD A,0Eh               ; Reload original value
0431: E6 0F       AND 0Fh                ; Low nibble again (0x0E)
0433: B0          OR B                   ; Combine to 0xEE (custom command?)
0434: CD EC 03    CALL dma_send_cmd_0x03EC ; Send constructed command

0437: 3E 04       LD A,04h               ; Parameter (step rate or head load?)
0439: 07          RLCA                   ; Shift left (0x08)
043A: E6 FE       AND 0FEh               ; Clear bit 0 (force even?)
043C: CD EC 03    CALL dma_send_cmd_0x03EC ; Send parameter
043F: C9          RET                    ; Return to caller

; --------------------------------------------------
; 0440: DMA Activation Routine
; Initializes DMA or FDC for disk operation
dma_action_1_0x0440:
0440: 3E 07       LD A,07h               ; Command 0x07 (Recalibrate?)
0442: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

0445: 3A 01 DF    LD A,(0DF01h)          ; Read DMA control/status
0448: CD EC 03    CALL dma_send_cmd_0x03EC ; Echo back as parameter?

044B: FB          EI                     ; Enable interrupts
044C: 76          HALT                   ; Wait for interrupt (FDC response)

044D: 3E 08       LD A,08h               ; Sense Interrupt Status
044F: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

0452: CD FA 03    CALL dma_read_result_0x03FA ; Read response byte 1
0455: CD FA 03    CALL dma_read_result_0x03FA ; Read response byte 2

0458: 3E FF       LD A,0FFh              ; Success flag (0xFF = done?)
045A: 32 06 DF    LD (0DF06h),A          ; Store in DMA status register
045D: C9          RET                    ; Return

; --------------------------------------------------
; 045E: Write DMA Configuration Block
; Sends 17-byte config to DMA controller
dma_write_config_0x045E:
045E: 0E C0       LD C,0C0h              ; DMA command/data port
0460: 06 11       LD B,17                ; 17 bytes to transfer
0462: ED B3       OTIR                   ; Write block from (HL) to port 0xC0
0464: CD AE 04    CALL dma_check_irq_0x04AE ; Validate IRQ status after write
0467: C0          RET NZ                 ; Return if status check failed (NZ)

; Continue DMA Setup
0468: 3E 46       LD A,46h               ; Command 0x46 (Read Sector?)
046A: CD 0A 05    CALL send_controller_cmd_0x050A ; Send with additional logging

046D: CD 26 05    CALL config_irq_mask_0x0526 ; Configure IRQ masks

0470: FB          EI                     ; Enable interrupts
0471: 76          HALT                   ; Wait for IRQ

0472: DA 70 04    JP C,0470h             ; If carry set, retry HALT (timeout?)

; Acknowledge IRQ
0475: 3E 47       LD A,47h               ; CTC control word (acknowledge?)
0477: D3 C8       OUT (0C8h),A           ; Send to CTC channel 0
0479: D3 C9       OUT (0C9h),A           ; Send to CTC channel 1

047B: 3E 64       LD A,64h               ; Another control value (timer?)
047D: D3 C8       OUT (0C8h),A           ; CTC channel 0
047F: D3 C9       OUT (0C9h),A           ; CTC channel 1

; Read and Store FDC Results
0481: CD FA 03    CALL dma_read_result_0x03FA ; Read result byte 1
0484: 32 07 DF    LD (0DF07h),A          ; Store in RAM
0487: CD FA 03    CALL dma_read_result_0x03FA ; Read result byte 2
048A: 32 08 DF    LD (0DF08h),A          ; Store (status flags?)
048D: CD FA 03    CALL dma_read_result_0x03FA ; Read result byte 3
0490: 32 09 DF    LD (0DF09h),A          ; Store
0493: CD FA 03    CALL dma_read_result_0x03FA ; Read result byte 4
0496: 32 0A DF    LD (0DF0Ah),A          ; Store
0499: CD FA 03    CALL dma_read_result_0x03FA ; Read result byte 5
049C: 32 0B DF    LD (0DF0Bh),A          ; Store
049F: CD FA 03    CALL dma_read_result_0x03FA ; Read result byte 6
04A2: 32 0C DF    LD (0DF0Ch),A          ; Store (end code?)

; Final Status Check
04A5: CD FA 03    CALL dma_read_result_0x03FA ; Read final status
04A8: 3A 08 DF    LD A,(0DF08h)          ; Reload status byte
04AB: E6 7F       AND 7Fh                ; Clear bit 7 (mask reserved bit)
04AD: C9          RET                    ; Return with status in A

; --------------------------------------------------
; 04AE: DMA Interrupt Status Verification
dma_check_irq_0x04AE:
04AE: CD 78 05    CALL dma_wait_ready_byte_0x0578 ; Wait for controller ready signal

04B1: 3A 02 DF    LD A,(0DF02h)          ; Read DMA status/control register
04B4: E6 01       AND 01h                ; Isolate bit 0 (IRQ flag?)
04B6: 32 05 DF    LD (0DF05h),A          ; Store flag state

04B9: 3A 02 DF    LD A,(0DF02h)          ; Re-read status
04BC: 0F          RRCA                   ; Shift bit 0 into carry
04BD: E6 7F       AND 7Fh                ; Mask off bit 7
04BF: 32 04 DF    LD (0DF04h),A          ; Store processed status
04C2: 47          LD B,A                 ; Save in B

; Compare with Previous Status
04C3: 3A 06 DF    LD A,(0DF06h)          ; Load previous status
04C6: A8          XOR B                  ; Check for changes
04C7: C8          RET Z                  ; Return if no change (stable)

; Status Changed — Retry Sequence
04C8: 3E 0F       LD A,0Fh               ; Command 0x0F (Force Interrupt?)
04CA: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

04CD: CD FB 04    CALL dma_finalize_check_0x04FB ; Process flags
04D0: CD EC 03    CALL dma_send_cmd_0x03EC ; Re-send command (redundant?)

04D3: 3A 04 DF    LD A,(0DF04h)          ; Load updated status
04D6: CD EC 03    CALL dma_send_cmd_0x03EC ; Send as confirmation

04D9: FB          EI                     ; Enable interrupts
04DA: 76          HALT                   ; Wait for IRQ

; Validate Post-Interrupt Status
04DB: 3E 08       LD A,08h               ; Sense Interrupt Status
04DD: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

04E0: CD FA 03    CALL dma_read_result_0x03FA ; Read result 1
04E3: CD FA 03    CALL dma_read_result_0x03FA ; Read result 2
04E6: 32 06 DF    LD (0DF06h),A          ; Store final status
04E9: 47          LD B,A                 ; Save in B
04EA: 3A 04 DF    LD A,(0DF04h)          ; Reload processed status
04ED: B8          CP B                   ; Compare with final status
04EE: CA F9 04    JP Z,irq_success_0x04F9 ; If match, success

; Status Mismatch — Error Path
04F1: 3E FF       LD A,0FFh              ; Error flag
04F3: 32 06 DF    LD (0DF06h),A          ; Store error in status
04F6: 3E 01       LD A,01h               ; Return NZ indicator
04F8: C9          RET                    ; Return with failure

irq_success_0x04F9:
04F9: AF          XOR A                  ; Clear A (success = 0)
04FA: C9          RET                    ; Return with success

; Finalize DMA Status Check
dma_finalize_check_0x04FB:
04FB: 3A 05 DF    LD A,(0DF05h)          ; Load latched flag (bit 0)
04FE: 07          RLCA                   ; Shift left twice
04FF: 07          RLCA                   ; Bit 0 → bit 2
0500: E6 04       AND 04h                ; Isolate bit 2
0502: C5          PUSH BC                ; Save BC
0503: 47          LD B,A                 ; Save shifted flag

0504: 3A 01 DF    LD A,(0DF01h)          ; Read DMA control register
0507: B0          OR B                   ; Merge with shifted flag
0508: C1          POP BC                 ; Restore BC
0509: C9          RET                    ; Return with merged value

; --------------------------------------------------
; 050A: Log and Send DMA/FDC Command
send_controller_cmd_0x050A:
050A: CD EC 03    CALL dma_send_cmd_0x03EC ; Send command in A

050D: CD FB 04    CALL dma_finalize_check_0x04FB ; Merge flags into status

0510: CD EC 03    CALL dma_send_cmd_0x03EC ; Send merged value

0513: 3A 04 DF    LD A,(0DF04h)          ; Load processed status
0516: CD EC 03    CALL dma_send_cmd_0x03EC ; Send as parameter

0519: 3A 05 DF    LD A,(0DF05h)          ; Load flag state
051C: CD EC 03    CALL dma_send_cmd_0x03EC ; Send flag

051F: 3A 03 DF    LD A,(0DF03h)          ; Load control register
0522: CD EC 03    CALL dma_send_cmd_0x03EC ; Send final parameter
0525: C9          RET                    ; Return

; --------------------------------------------------
; 0526: Configure IRQ Masks
config_irq_mask_0x0526:
0526: 3E 01       LD A,01h               ; Mask or control byte
0528: CD EC 03    CALL dma_send_cmd_0x03EC ; Send to FDC

052B: 3E 12       LD A,12h               ; Another control value
052D: CD EC 03    CALL dma_send_cmd_0x03EC ; Send

0530: 3E 0A       LD A,0Ah               ; Possibly retry count
0532: CD EC 03    CALL dma_send_cmd_0x03EC ; Send

0535: 3E FF       LD A,0FFh              ; Full mask or end signal
0537: CD EC 03    CALL dma_send_cmd_0x03EC ; Send
053A: C9          RET                    ; Return

; --------------------------------------------------
; 053B: Clear A and Exit Interrupt
dma_clear_and_exit_0x053B:
053B: AF          XOR A                  ; Clear A (success or reset)
053C: FB          EI                     ; Enable interrupts
053D: ED 4D       RETI                   ; Return from interrupt (IM2)

; Lone RETI (Default Interrupt Exit?)
053E: ED 4D       RETI                   ; Standalone interrupt return

; --------------------------------------------------
; 053F: DMA Configuration Block 1
; 17-byte static config for DMA transfer (first attempt)
dma_config1_0x053F:
053F: C3 05 CF    JP dma_jump_target_0xCF05 ; ISR or trap address
0542: 79          .db 0x79               ; Drive/head flags (01111001b: drive 1, head 0?)
0543: 00          .db 0x00               ; Track number (0)
0544: E0          .db 0xE0               ; Sector ID (initial value)
0545: FF          .db 0xFF               ; Sector length (placeholder?)
0546: 11          .db 0x11               ; DMA buffer address = 0x2814
0547: 14          .db 0x14
0548: 28          .db 0x28
0549: 85          .db 0x85               ; Sector count or flags
054A: F1          .db 0xF1               ; FDC command (Read Sector?)
054B: 8A          .db 0x8A               ; Data length or flags
054C: CF          .db 0xCF               ; Gap length or control byte
054D: 01          .db 0x01               ; Parameter (drive select?)
054E: CF          .db 0xCF               ; Repeated control byte
054F: 87          .db 0x87               ; Final status/control byte

; --------------------------------------------------
; 0550: DMA Configuration Block 2
; Alternate 17-byte config (retry with different sector ID)
dma_config2_0x0550:
0550: C3 05 CF    JP dma_jump_target_0xCF05 ; Same ISR/trap address
0553: 79          .db 0x79               ; Same drive/head flags
0554: 00          .db 0x00               ; Track 0
0555: F2          .db 0xF2               ; Different sector ID (retry value)
0556: FF          .db 0xFF               ; Sector length placeholder
0557: 11          .db 0x11               ; Same buffer address (0x2814)
0558: 14          .db 0x14
0559: 28          .db 0x28
055A: 85          .db 0x85               ; Same flags
055B: F1          .db 0xF1               ; Same command
055C: 8A          .db 0x8A               ; Same data length
055D: CF          .db 0xCF               ; Same gap/control
055E: 01          .db 0x01               ; Same parameter
055F: CF          .db 0xCF               ; Same control
0560: 87          .db 0x87               ; Same final byte

; --------------------------------------------------
; 0561: DMA Status Check (Incomplete?)
dma_check_busy_0x0561:
0561: 52          LD D,D                 ; No-op (padding or artifact)
0562: 4F          LD C,A                 ; Possibly incomplete routine

dma_input_check_0x0563:
0563: DB 98       IN A,(98h)             ; Read DMA or FDC status port
0565: E6 01       AND 01h                ; Check bit 0 (busy/ready flag)
0567: C9          RET                    ; Return with flag in A

; --------------------------------------------------
; 0568: Reset DMA Port with Delay
dma_reset_0x0568:
0568: AF          XOR A                  ; Clear A
0569: D3 98       OUT (98h),A            ; Reset DMA/FDC status port

delay_outer_loop_0x056B:
056B: 3E DC       LD A,0DCh              ; Outer loop counter = 220
delay_loop_1_0x056D:
056D: 06 96       LD B,96h               ; Inner loop counter = 150
delay_loop_2_0x056F:
056F: 05          DEC B                  ; Decrement inner counter
0570: C2 6F 05    JP NZ,delay_loop_2_0x056F ; Loop 150 times
0573: 3D          DEC A                  ; Decrement outer counter
0574: C2 6D 05    JP NZ,delay_loop_1_0x056D ; Loop 220 times (total ~33,000 cycles)
0577: C9          RET                    ; Return after delay

; --------------------------------------------------
; 0578: Wait for Controller Ready
dma_wait_ready_byte_0x0578:
0578: CD 63 05    CALL dma_input_check_0x0563 ; Check port 0x98 status
057B: C2 81 05    JP NZ,dma_wait_ready_loop_0x0581 ; If not ready, loop

057E: CD 68 05    CALL dma_reset_0x0568  ; Reset port 0x98 with delay

dma_wait_ready_loop_0x0581:
0581: AF          XOR A                  ; Clear A
0582: D3 98       OUT (98h),A            ; Reset status again (redundant?)

; Configure CTC or DMA
0584: 3E 03       LD A,03h               ; Control value (mode?)
0586: D3 C8       OUT (0C8h),A           ; Send to CTC channel 0
0588: D3 C9       OUT (0C9h),A           ; Send to CTC channel 1

058A: 3E 47       LD A,47h               ; Command or mask (acknowledge?)
058C: D3 C8       OUT (0C8h),A           ; CTC channel 0
058E: 3E FF       LD A,0FFh              ; Full mask or timer value
0590: D3 C9       OUT (0C9h),A           ; CTC channel 1

0592: 3E A0       LD A,0A0h              ; Another control byte (disable?)
0594: D3 C8       OUT (0C8h),A           ; CTC channel 0
0596: D3 C9       OUT (0C9h),A           ; CTC channel 1
0598: C9          RET                    ; Return when ready

; --------------------------------------------------
; 0599: Disk Not Ready Error Handler
0599: CD 81 05    CALL dma_error_wait_0x0581 ; Wait for controller reset
059C: 11 A6 05    LD DE,msg_disk_not_ready_0x05A6 ; Point to "DISK NOT READY !!!" message
059F: CD E0 03    CALL print_string_dollar_0x03E0 ; Display error
05A2: 37          SCF                    ; Set carry flag (error condition)
05A3: FB          EI                     ; Enable interrupts
05A4: ED 4D       RETI                   ; Return from interrupt

; Disk Not Ready Message (Continued from 0x05A6)
msg_disk_not_ready_0x05A6:
05A6: 0A          .db 0Ah                ; LF (line feed)
05A7: 0D          .db 0Dh                ; CR (carriage return)
05A8: 44          .db 'D'                ; "DISK NOT READY !!!" in YUSCII encoding
05A9: 49          .db 'I'
05AA: 53          .db 'S'
05AB: 4B          .db 'K'
05AC: 20          .db ' '
05AD: 4E          .db 'N'
05AE: 4F          .db 'O'
05AF: 54          .db 'T'
05B0: 20          .db ' '
05B1: 52          .db 'R'
05B2: 45          .db 'E'
05B3: 41          .db 'A'
05B4: 44          .db 'D'
05B5: 59          .db 'Y'
05B6: 20          .db ' '
05B7: 21          .db '!'
05B8: 21          .db '!'
05B9: 21          .db '!'
05BA: 24          .db 24h                ; '$' terminator for print_string_dollar

; Possible Text Filler or Debug Output
05BB: 21 21 21    LD HL,2121h            ; Load HL with 0x2121 ("!!" in ASCII)
05BE: 21 21 21    LD HL,2121h            ; Repeated (padding or border?)
05C1: 21 21 21    LD HL,2121h            ; Repeated again
05C4: 21 21 24    LD HL,2421h            ; Ends with 0x2421 ("!$") — possibly string end marker

; Strange Text String (Debug or Placeholder?)
05C5: 65          .db 'e'                ; "err3" followed by CR/LF/TAB
05C6: 72          .db 'r'
05C7: 72          .db 'r'
05C8: 33          .db '3'
05C9: 0D          .db 0Dh                ; CR
05CA: 0A          .db 0Ah                ; LF
05CB: 09          .db 09h                ; TAB
05CC: 6C          .db 'l'                ; "lda stat1 ! ani 10h  cnz err5"
05CD: 64          .db 'd'
05CE: 61          .db 'a'
05CF: 20          .db ' '
05D0: 73          .db 's'
05D1: 74          .db 't'
05D2: 61          .db 'a'
05D3: 74          .db 't'
05D4: 31          .db '1'
05D5: 20          .db ' '
05D6: 21          .db '!'
05D7: 20          .db ' '
05D8: 61          .db 'a'
05D9: 6E          .db 'n'
05DA: 69          .db 'i'
05DB: 20          .db ' '
05DC: 31          .db '1'
05DD: 30          .db '0'
05DE: 68          .db 'h'
05DF: 20          .db ' '
05E0: 20          .db ' '
05E1: 20          .db ' '
05E2: 20          .db ' '
05E3: 21          .db '!'
05E4: 20          .db ' '
05E5: 63          .db 'c'
05E6: 6E          .db 'n'
05E7: 7A          .db 'z'
05E8: 20          .db ' '
05E9: 65          .db 'e'
05EA: 72          .db 'r'
05EB: 72          .db 'r'
05EC: 35          .db '5'
05ED: 0D          .db 0Dh                ; CR
05EE: 0A          .db 0Ah                ; LF
; Note: This resembles 8080/Z80 mnemonics (LDA STAT1, ANI 10h, CNZ ERR5), possibly debug code or a disassembler artifact

; Loading System Track Message (Incomplete)
msg_loading_system_track_0x05EF:
05EF: 6C          .db 'l'                ; "lda stat1 ! an" — truncated string
05F0: 64          .db 'd'
05F1: 61          .db 'a'
05F2: 20          .db ' '
05F3: 73          .db 's'
05F4: 74          .db 't'
05F5: 61          .db 'a'
05F6: 74          .db 't'
05F7: 31          .db '1'
05F8: 20          .db ' '
05F9: 21          .db '!'
05FA: 20          .db ' '
05FB: 61          .db 'a'
05FC: 6E          .db 'n'
05FD: FF          .db 0FFh               ; RST 38h or padding (not a proper terminator)
05FE: FF          .db 0FFh
05FF: FF          .db 0FFh
0600: FF          .db 0FFh
0601: FF          .db 0FFh
0602: FF          .db 0FFh

; --------------------------------------------------
; 0603: RST 38h Trap Region
; Filled with RST 38h (0xFF) instructions, likely unhandled interrupt traps or padding
0603: FF          RST 38h                ; Trap to 0x0038 (unimplemented handler?)
0604: FF          RST 38h
0605: FF          RST 38h
0606: FF          RST 38h
0607: FF          RST 38h
0608: FF          RST 38h
0609: FF          RST 38h
060A: FF          RST 38h
060B: FF          RST 38h
060C: FF          RST 38h
060D: FF          RST 38h
060E: FF          RST 38h
060F: FF          RST 38h
0610: FF          RST 38h
0611: FF          RST 38h
0612: FF          RST 38h
0613: FF          RST 38h
0614: FF          RST 38h
0615: FF          RST 38h
0616: FF          RST 38h
0617: FF          RST 38h
; Continues beyond 0x0617 as padding or trap area until next meaningful code
