;; THE COMPLETE PARTNER MODEL P ROM DISASSEMBLY
;; TOMAZ STIH, LONDON 2025

; --------------------------------------------------
; 0000: Entry point (no DI — interrupts left enabled!)
0000: C3 37 01    JP init_sio_0x0137     ; Jump to SIO initialization (L0001)

; --------------------------------------------------
; SIO init continues here — this becomes L0006
0003: 31 C0 FF    LD SP,0FFC0h           ; Set stack pointer near top of RAM
0006: CD B8 00    CALL newline_0x00B8    ; Output CR+LF

; Send greeting char
0009: 3E 2A       LD A,2Ah               ; '*'
000B: CD A9 00    CALL putchar_0x00A9    ; Output character to console

; Wait for keypress
000E: CD 9F 00    CALL wait_key_0x009F   ; Wait for RX ready and read char
0011: E6 DF       AND 0DFh               ; Mask with 0xDF
0013: FE 46       CP 46h                 ; Compare with 'F'
0015: CA 0F 02    JP Z,main_loop_0x020F  ; If 'F', jump to main loop
0018: 3E 3F       LD A,3Fh               ; '?'
001A: CD A9 00    CALL putchar_0x00A9    ; Output '?'
001D: 18 E4       JR 0003h               ; Jump back to SP init (L0006)
; --------------------------------------------------
; Padding / Reserved area? No execution path here
001F: 00          NOP
0020: 00          NOP
0021: 00          NOP
0022: 00          NOP
0023: 00          NOP
0024: 00          NOP
0025: 00          NOP
0026: 00          NOP
0027: 00          NOP
0028: 00          NOP
0029: 00          NOP
002A: 00          NOP
002B: 00          NOP

; --------------------------------------------------
; Possibly a return path — stack fix? (POP HL + JMP)
002C: E1          POP HL
002D: C3 D5 19    JP unknown_0x19D5         ; Some late-stage handler

; --------------------------------------------------
; Called from external code — output memory debug?
0030: F5          PUSH AF
0031: CD 18 48    CALL debug_init_0x4818    ; Possibly initialize debugger/monitor

0034: 3A 7D 3C    LD A,(3C7Dh)
0037: B7          OR A
0038: C4 C0 2C    CALL NZ,handle_status1_0x2CC0

003B: 3A 22 3A    LD A,(3A22h)
003E: B7          OR A
003F: C4 F1 2C    CALL NZ,handle_status2_0x2CF1

; Possibly update memory test counter?
0042: F1          POP AF
0043: 21 1B 3A    LD HL,3A1Bh
0046: 34          INC (HL)
0047: 7E          LD A,(HL)
0048: 3D          DEC A
0049: C2 AB 2B    JP NZ,memory_counter_loop_0x2BAB

; Possibly check if system was started
004C: 21 EC 3B    LD HL,3BECh
004F: 7E          LD A,(HL)
0050: B7          OR A
0051: C2 34 2B    JP NZ,boot_resume_0x2B34

; Some fallback/reset state?
0054: 21 4A 3B    LD HL,3B4Ah
0057: 7E          LD A,(HL)
0058: B7          OR A
0059: C2 34 2B    JP NZ,boot_resume_0x2B34

; Setup for memory copy (DMA buffer?)
005C: 21 58 3D    LD HL,3D58h   ; Source?
005F: 23          INC HL
0060: 01 06 00    LD BC,0006h   ; Length = 6 bytes
0063: 11 EC 3B    LD DE,3BECh   ; Destination?
0066: C3 18 00    JP main_loop_0x0018  ; Loop back (??)

; --------------------------------------------------
; Output HL in hex (high byte, then low byte)
0069: CD B8 00    CALL newline_0x00B8         ; Output newline first
006C: 7C          LD A,H
006D: CD 79 00    CALL put_hex_0x0079         ; Print high byte of HL
0070: 7D          LD A,L
0071: CD 79 00    CALL put_hex_0x0079         ; Print low byte of HL
0074: 3E 20       LD A,20h                    ; Space character
0076: C3 A9 00    JP putchar_0x00A9           ; Print space

put_hex_0x0079:
0079: C5          PUSH BC                 ; Save BC
007A: 47          LD B,A                  ; Store original A in B
007B: CB 2F       SRA A                   ; Shift A right 4x to get high nibble
007D: CB 2F
007F: CB 2F
0081: CB 2F
0083: E6 0F       AND 0Fh                 ; Mask lower 4 bits
0085: CD 90 00    CALL nibble_to_ascii_0x0090  ; Print high nibble
0088: 78          LD A,B                  ; Restore original A
0089: E6 0F       AND 0Fh                 ; Isolate low nibble
008B: CD 90 00    CALL nibble_to_ascii_0x0090  ; Print low nibble
008E: C1          POP BC                  ; Restore BC
008F: C9          RET

nibble_to_ascii_0x0090:
0090: FE 0A       CP 0Ah                  ; If A < 10, it's a digit
0092: FA 99 00    JP M,nibble_is_digit_0x0099
0095: C6 37       ADD A,37h               ; A-F = A + 55
0097: 18 02       JR print_ascii_0x009B

nibble_is_digit_0x0099:
0099: C6 30       ADD A,30h               ; 0-9 = A + 48

print_ascii_0x009B:
009B: CD A9 00    CALL putchar_0x00A9     ; Output character
009E: C9          RET

wait_key_0x009F:
009F: DB D9       IN A,(0D9h)             ; Check SIO status register
00A1: CB 47       BIT 0,A                 ; Bit 0 set if data available
00A3: 28 FA       JR Z,wait_key_0x009F    ; Wait for key
00A5: DB D8       IN A,(0D8h)             ; Read character
00A7: CB BF       RES 7,A                 ; Clear bit 7 (maybe parity/flag)
00A9: F5          PUSH AF                 ; Begin putchar: push char for TX

putchar_wait_0x00AA:
00AA: DB D9       IN A,(0D9h)             ; Read status from SIO (port 0xD9)
00AC: CB 57       BIT 2,A                 ; Check if TX buffer is ready (bit 2)
00AE: 28 FA       JR Z,putchar_wait_0x00AA ; Wait until ready
00B0: F1          POP AF                  ; Restore character to A
00B1: D3 D8       OUT (0D8h),A            ; Send character to SIO
00B3: C9          RET

; Alias: newline (CR + LF)
newline_0x00B4:
00B4: 3E 20       LD A,20h                ; Load space char (fallback?)
00B6: 18 F1       JR putchar_0x00A9       ; Jump to putchar

newline_0x00B8:
00B8: 3E 0A       LD A,0Ah                ; Line feed
00BA: CD A9 00    CALL putchar_0x00A9
00BD: 3E 0D       LD A,0Dh                ; Carriage return
00BF: 18 E8       JR putchar_0x00A9

; --------------------------------------------------
; This block performs a basic RAM test or pattern 
; fill using custom write/verify logic.
mem_test_0x00C1:
00C1: 21 A8 01    LD HL,01A8h             ; HL = 0x01A8 (keyboard/memory buff?)
00C4: CD 86 01    CALL print_string_0x0186 ; Print message from [HL]

00C7: 21 00 20    LD HL,2000h             ; Start of test region
00CA: 01 80 FF    LD BC,0FF80h            ; BC = end (HL - BC = length)
00CD: 16 02       LD D,02h                ; Number of pattern loops
00CF: 3E 00       LD A,00h                ; Starting pattern
mem_test_loop_0x00D1:
00D1: D5          PUSH DE                  ; Save pattern loop counter
00D2: F5          PUSH AF                  ; Save current pattern
00D3: CD DE 00    CALL write_verify_0x00DE ; Write and verify with pattern A
00D6: F1          POP AF                   ; Restore pattern
00D7: D1          POP DE                   ; Restore loop counter
00D8: C6 55       ADD A,55h                ; Modify pattern (A += 0x55)
00DA: 15          DEC D                    ; D = D - 1
00DB: 20 F4       JR NZ,mem_test_loop_0x00D1 ; Repeat if not finished
00DD: C9          RET

;; Write/Verify Pair with Complementation Logic
write_verify_0x00DE:
00DE: CD EF 00    CALL write_pattern_0x00EF ; Write pattern + complement
00E1: D3 90       OUT (90h),A              ; Output A? (maybe for status LED)
00E3: CD EF 00    CALL write_pattern_0x00EF ; Write again (verify?)
00E6: CD 02 01    CALL verify_pattern_0x0102 ; Check memory contents
00E9: D3 88       OUT (88h),A              ; Another I/O port (verify success?)
00EB: CD 02 01    CALL verify_pattern_0x0102 ; Verify again?
00EE: C9          RET

;; Write Pattern + Complement to memory
write_pattern_0x00EF:
00EF: F5          PUSH AF
00F0: E5          PUSH HL
00F1: 57          LD D,A                   ; D = pattern
00F2: 2F          CPL                      ; A = ~A
00F3: 5F          LD E,A                   ; E = complement

write_loop_0x00F4:
00F4: 72          LD (HL),D                ; Write pattern
00F5: 23          INC HL
00F6: 73          LD (HL),E                ; Write complement
00F7: 23          INC HL
00F8: E5          PUSH HL
00F9: B7          OR A                     ; Clear flags
00FA: ED 42       SBC HL,BC                ; End reached?
00FC: E1          POP HL
00FD: 38 F5       JR C,write_loop_0x00F4   ; Loop if HL < HL+BC
00FF: E1          POP HL
0100: F1          POP AF
0101: C9          RET

verify_pattern_0x0102:
0102: E5          PUSH HL
0103: F5          PUSH AF
0104: 57          LD D,A                   ; D = pattern
0105: 2F          CPL                      ; A = ~A
0106: 5F          LD E,A                   ; E = complement

verify_loop_0x0107:
0107: 7E          LD A,(HL)                ; Load byte
0108: BA          CP D                     ; A == pattern?
0109: 20 10       JR NZ,verify_fail_0x011B ; If mismatch, jump to error

010B: 23          INC HL
010C: 7E          LD A,(HL)
010D: BB          CP E                     ; A == complement?
010E: 20 0B       JR NZ,verify_fail_0x011B ; Mismatch → fail

0110: 23          INC HL
0111: E5          PUSH HL
0112: B7          OR A                     ; Clear flags
0113: ED 42       SBC HL,BC                ; Done?
0115: E1          POP HL
0116: 38 EF       JR C,verify_loop_0x0107  ; Continue if more to check

0118: F1          POP AF
0119: E1          POP HL
011A: C9          RET

;; If verification failed — show error string and restart test
verify_fail_0x011B:
011B: 21 24 01    LD HL,error_string_0x0124
011E: CD 86 01    CALL print_string_0x0186 ; Print "MEMORY ERROR!"
0121: C3 03 00    JP mem_test_0x00C1       ; Restart memory test

;; Error message string ("MEMORY ERROR!"), stored as raw bytes
error_string_0x0124:
0124: 0D          ; <CR>
0125: 0A          ; <LF>
0126: 4D          ; M
0127: 45          ; E
0128: 4D          ; M
0129: 4F          ; O
012A: 52          ; R
012B: 59          ; Y
012C: 20          ;  
012D: 45          ; E
012E: 52          ; R
012F: 52          ; R
0130: 4F          ; O
0131: 52          ; R
0132: 20          ;  
0133: 21          ; !
0134: 21          ; !
0135: 00          ; null terminator

;; SIO Initialization Routine 
init_sio_0x0137:
0137: 0E D9       LD C,0D9h                ; SIO 1 - Port B command port
0139: 21 8F 01    LD HL,sio_init_block_0x018F
013C: 06 07       LD B,07h                 ; 7 control bytes
013E: ED B3       OTIR                     ; Output HL → (C), B times

013F: 0E DB       LD C,0DBh                ; SIO 1 - Port A
0141: 21 8F 01    LD HL,sio_init_block_0x018F
0144: 06 07       LD B,07h
0146: ED B3       OTIR

0148: 0E E1       LD C,0E1h                ; SIO 2 - Port B
014A: 21 8F 01    LD HL,sio_init_block_0x018F
014D: 06 07       LD B,07h
014F: ED B3       OTIR

0151: 0E E3       LD C,0E3h                ; SIO 2 - Port A
0153: 21 8F 01    LD HL,sio_init_block_0x018F
0156: 06 07       LD B,07h
0158: ED B3       OTIR

;; Continue boot with memory test and banner
015B: 31 C0 FF    LD SP,0FFC0h             ; Set stack pointer again
; Already seen:
015E: CD C1 00    CALL mem_test_0x00C1     ; Run memory test (twice, 2 patterns)

; Print banner string at 0x0196
0161: 21 96 01    LD HL,banner_string_0x0196
0164: CD 86 01    CALL print_string_0x0186 ; Show welcome banner

; Load jump address from system vector (?!)
0167: 2A FE 07    LD HL,(07FEh)            ; Load jump target from memory

; Output ASCII 0x04 to SIO (EOT?)
016A: 3E 04       LD A,04h                 ; ASCII EOT or custom signal
016C: CD A9 00    CALL putchar_0x00A9      ; Output it

; Set up IX with jump address (indirect monitor jump?)
016F: DD 2A FC 07 LD IX,(07FCh)            ; Load jump vector address

; Output system vector via ports 0xAE and 0xAF
system_vector_out_0x0173:
0173: 3A FC 07    LD A,(07FCh)
0176: D3 AE       OUT (0AEh),A
0178: 3A FD 07    LD A,(07FDh)
017B: D3 AF       OUT (0AFh),A

; Call system init routines (likely system monitor)
017D: CD 00 02    CALL system_entry_0x0200
0180: CD 03 02    CALL system_entry2_0x0203

; Final jump to main application / monitor loop
0183: C3 0F 02    JP main_loop_0x020F

;; String Printer: $-terminated string at (HL)
print_string_0x0186:
0186: 7E          LD A,(HL)                ; Load char from string
0187: B7          OR A                     ; Is it 0?
0188: C8          RET Z                    ; Null-terminated

0189: CD A9 00    CALL putchar_0x00A9      ; Output char
018C: 23          INC HL                   ; Next char
018D: 18 F7       JR print_string_0x0186   ; Loop

;; SIO init data - Control Register Values for all 4 ports
sio_init_block_0x018F:
018F: 18          ; WR4: async, x16 clock mode
0190: 04          ; WR1: no parity, 1 stop bit
0191: 44          ; WR3: 8-bit RX enable
0192: 03          ; WR1: RX interrupt enable
0193: C1          ; WR9: Master int enable
0194: 05          ; WR5: TX enable, RTS on
0195: 68          ; WR14: reset error/status

;; banner string
banner_string_0x0196:
0196: 1C          ; <non-printable>
0197: 44          ; 'D'
0198: 45          ; 'E'
0199: 4C          ; 'L'
019A: 54          ; 'T'
019B: 41          ; 'A'
019C: 20          ; ' '
019D: 50          ; 'P'
019E: 41          ; 'A'
019F: 52          ; 'R'
01A0: 54          ; 'T'
01A1: 4E          ; 'N'
01A2: 45          ; 'E'
01A3: 52          ; 'R'
01A4: 20          ; ' '
01A5: 2F          ; '/'
01A6: 46          ; 'F'
; End of banner string — null terminator
01A7: 00          ; null terminator (end of "DELTA PARTNER /F")

; string <CR><LF><LF>TESTING MEMORY ...
01A8: 0D          ; CR
01A9: 0A          ; LF
01AA: 0A          ; LF
01AB: 54          ; T
01AC: 45          ; E
01AD: 53          ; S
01AE: 54          ; T
01AF: 49          ; I
01B0: 4E          ; N
01B1: 47          ; G
01B2: 20          ;  
01B3: 4D          ; M
01B4: 45          ; E
01B5: 4D          ; M
01B6: 4F          ; O
01B7: 52          ; R
01B8: 59          ; Y
01B9: 20          ;  
01BA: 2E          ; .
01BB: 2E          ; .
01BC: 2E          ; .
01BD: 20          ;  
01BE: 00          ; null terminator

; Message: "No ROM found. Boot failed." (approximate)
01BF: 01          ; Start of ??? maybe vector
01C0: 4E          ; 'N'
01C1: 6F          ; 'o'
01C2: 20          ; ' '
01C3: 00          ; end?

01C4: 20          ; ' '
01C5: 46          ; 'F'
01C6: 61          ; 'a'
01C7: 74          ; 't'
01C8: 58          ; 'X'
01C9: 52          ; 'R'
01CA: 45          ; 'E'
01CB: 54          ; 'T'
01CC: 3A          ; ':'
01CD: 09          ; TAB?
01CE: 52          ; 'R'
01CF: 45          ; 'E'
01D0: 54          ; 'T'
01D1: 0D          ; CR
01D2: 0A          ; LF
01D3: 0D          ; CR
01D4: 0A          ; LF

;; WTF?
01D5: 09          ; TAB or non-printable char
01D6: 6E          ; 'n'
01D7: 6F          ; 'o'
01D8: 70          ; 'p'
01D9: 20          ; ' '
01DA: 21          ; '!'
01DB: 20          ; ' '
01DC: 6E          ; 'n'
01DD: 6F          ; 'o'
01DE: 70          ; 'p'
01DF: 20          ; ' '
01E0: 21          ; '!'
01E1: 6E          ; 'n'
01E2: 6F          ; 'o'
01E3: 70          ; 'p'
01E4: 20          ; ' '
01E5: 21          ; '!'
01E6: 6E          ; 'n'
01E7: 6F          ; 'o'
01E8: 70          ; 'p'
01E9: 20          ; ' '
01EA: 21          ; '!'
01EB: 6F          ; 'o'
01EC: 70          ; 'p'
01ED: 20          ; ' '
01EE: 21          ; '!'
01EF: 6F          ; 'o'
01F0: 70          ; 'p'
01F1: 0D          ; CR
01F2: 0A          ; LF

; Decorative ASCII border
01F3: 3B          ; ';'
01F4: 2D          ; '-'
01F5: 2D          ; '-'
01F6: 2D          ; '-'
01F7: 2D          ; '-'
01F8: 2D          ; '-'
01F9: 2D          ; '-'
01FA: 2D          ; '-'
01FB: 2D          ; '-'
01FC: 2D          ; '-'
01FD: 2D          ; '-'
01FE: 2D          ; '-'
01FF: 2D          ; '-'

;; Interrupt/Trap Vector Table
system_entry_0x0200:
0200: C3 06 04    JP reset_handler_0x0406      ; Vector 0: RESET → system setup

0203: C3 12 02    JP ret_0x0212                ; Vector 1: RET
0206: C3 12 02    JP ret_0x0212                ; Vector 2: RET
0209: C3 12 02    JP ret_0x0212                ; Vector 3: RET
020C: C3 12 02    JP ret_0x0212                ; Vector 4: RET

main_loop_0x020F:
020F: C3 1E 02    JP dma_int_handler_0x021E    ; Vector 5: DMA interrupt handler

;; Default interrupt return routine
ret_0x0212:
0212: C9          RET                         ; Return from any vector slot

;; Unknown, unused?
0213: 00          NOP
0214: 00          NOP
0215: 00          NOP
0216: 00          NOP
0217: 00          NOP
0218: 3B          DEC SP
0219: 05          DEC B
021A: 99          SBC A,C
021B: 05          DEC B
021C: 3B          DEC SP
021D: 05          DEC B

;; DMA Interrupt Handler (dma_int_handler_0x021E)
dma_int_handler_0x021E:
021E: 31 35 DF    LD SP,0DF35h                ; Set stack for handler
0221: 3E 03       LD A,03h
0223: D3 CA       OUT (0CAh),A                ; Configure DMA/CTC mode?

0225: 11 07 03    LD DE,dma_msg_reading_0x0307
0228: CD E0 03    CALL print_string_dollar_0x03E0

022B: 3E 00       LD A,00h
022D: 32 01 DF    LD (0DF01h),A               ; Status port?

0230: CD 40 04    CALL dma_action_1_0x0440
0233: 3E 01       LD A,01h
0235: 32 01 DF    LD (0DF01h),A

0238: CD 40 04    CALL dma_action_1_0x0440

023B: 3E 0A       LD A,0Ah
023D: 32 00 DF    LD (0DF00h),A               ; Setup transfer count

;; DMA setup: control register writes
0240: 3E 01       LD A,01h
0242: 32 03 DF    LD (0DF03h),A               ; Write to DMA control register

0245: 3E 00       LD A,00h
0247: 32 02 DF    LD (0DF02h),A               ; Possibly clear flags or reset
;; set up HL to point to a DMA configuration block (first block):
024A: 21 3F 05    LD HL,dma_config_1_0x053F
024D: CD 5E 04    CALL dma_write_config_0x045E ; Write 17 bytes to DMA controller
0250: CA 69 02    JP Z,dma_altpath_0x0269     ; If config failed, try alternate path

; Check DMA completion flag
0253: 3A 00 DF    LD A,(0DF00h)
0256: B7          OR A
0257: CA AD 02    JP Z,dma_status_handler_0x02AD ; If status still 0, jump

025A: 3D          DEC A                        ; Decrement counter
025B: 32 00 DF    LD (0DF00h),A                ; Store back updated count

025E: 3E 02       LD A,02h
0260: 32 02 DF    LD (0DF02h),A                ; Update control register
0263: CD AE 04    CALL dma_check_irq_0x04AE    ; Compare status bits
0266: C3 40 02    JP 0x0240                     ; Jump back to retry DMA
dma_altpath_0x0269:
0269: 3E 0A       LD A,0Ah                    ; Set block count or retry value
026B: 32 00 DF    LD (0DF00h),A

dma_retry_loop_0x026E:
026E: 3E 01       LD A,01h
0270: 32 03 DF    LD (0DF03h),A               ; DMA control
0273: 3E 01       LD A,01h
0275: 32 02 DF    LD (0DF02h),A               ; Alternate mode?

0278: 21 50 05    LD HL,dma_config_2_0x0550   ; Use second DMA config block
027B: CD 5E 04    CALL dma_write_config_0x045E ; Write it to DMA controller
027E: CA 97 02    JP Z,dma_romscan_0x0297     ; If failed, try scanning for ROM

;; Retry loop for DMA confirmation
0281: 3A 00 DF    LD A,(0DF00h)               ; Read DMA status
0284: B7          OR A
0285: CA AD 02    JP Z,dma_status_handler_0x02AD ; Retry fallback again

0288: 3D          DEC A
0289: 32 00 DF    LD (0DF00h),A               ; Store decremented counter

028C: 3E 02       LD A,02h
028E: 32 02 DF    LD (0DF02h),A               ; Trigger new transfer?

0291: CD AE 04    CALL dma_check_irq_0x04AE   ; Status validation
0294: C3 6E 02    JP dma_retry_loop_0x026E    ; Retry DMA again

;; ROM scan fallback — check for signature
dma_romscan_0x0297:
0297: 3A 00 E0    LD A,(0E000h)               ; Check for JMP (C3h) at E000
029A: FE C3       CP 0C3h
029C: CA 00 F6    JP Z,boot_from_rom_0xF600   ; Valid JMP — jump to ROM

029F: FE 31       CP 31h                      ; Check for LD SP,nn (reset vec?)
02A1: CA 00 F6    JP Z,boot_from_rom_0xF600

02A4: 11 72 03    LD DE,error_reading_0x0372  ; ROM not valid — show error
02A7: CD E0 03    CALL print_string_dollar_0x03E0
02AA: C3 03 00    JP mem_test_0x00C1          ; Restart memory test (soft reboot)

;; DMA Status Handler
dma_status_handler_0x02AD:
02AD: 3A 08 DF    LD A,(0DF08h)               ; Read DMA status/error bits
02B0: E6 7F       AND 7Fh                     ; Mask out highest bit
02B2: C4 E0 02    CALL NZ,dma_err_bit7_0x02E0 ; If any of bits 0–6 set → call handler

02B5: 3A 08 DF    LD A,(0DF08h)               ; Check again
02B8: E6 20       AND 20h                     ; Bit 5 — "sector not found" or similar
02BA: C4 E4 02    CALL NZ,dma_err_bit5_0x02E4

02BD: 3A 08 DF    LD A,(0DF08h)
02C0: E6 04       AND 04h                     ; Bit 2 — "data CRC error"
02C2: C4 EB 02    CALL NZ,dma_err_bit2_0x02EB

02C5: 3A 08 DF    LD A,(0DF08h)
02C8: E6 10       AND 10h                     ; Bit 4 — "write protect"
02CA: C4 F9 02    CALL NZ,dma_err_bit4_0x02F9

02CD: 3A 08 DF    LD A,(0DF08h)
02D0: E6 01       AND 01h                     ; Bit 0 — "ID CRC error"?
02D2: C4 F2 02    CALL NZ,dma_err_bit0_0x02F2

02D5: 3A 0C DF    LD A,(0DF0Ch)               ; Get controller register byte (e.g. end code)
02D8: FE 12       CP 12h                      ; Check if expected value
02DA: C4 00 03    CALL NZ,dma_unexpected_0x0300 ; If not, call unexpected handler

02DD: C3 03 00    JP mem_test_0x00C1          ; Reboot system: restart mem tst

;; DMA Error Bit 7 Handler – General Error
dma_err_bit7_0x02E0:
02E0: CD A2 03    CALL dma_show_regstate_0x03A2  ; Display controller registers
02E3: C9          RET

;; DMA Error Bit 5 – "Sector Not Found"
dma_err_bit5_0x02E4:
02E4: 11 1F 03    LD DE,msg_sector_not_found_0x031F
02E7: CD E0 03    CALL print_string_dollar_0x03E0
02EA: C9          RET

;; DMA Error Bit 2 – "Data CRC Error" 
dma_err_bit2_0x02EB:
02EB: 11 2B 03    LD DE,msg_crc_error_0x032B
02EE: CD E0 03    CALL print_string_dollar_0x03E0
02F1: C9          RET

;; DMA Error Bit 0 – "ID Field CRC Error"
dma_err_bit0_0x02F2:
02F2: 11 3E 03    LD DE,msg_idcrc_error_0x033E
02F5: CD E0 03    CALL print_string_dollar_0x03E0
02F8: C9          RET

;; DMA Error Bit 4 – "Write Protect or Device Error" 
dma_err_bit4_0x02F9:
02F9: 11 55 03    LD DE,msg_protect_or_misc_0x0355
02FC: CD E0 03    CALL print_string_dollar_0x03E0
02FF: C9          RET

;; DMA Unexpected State Handler
dma_unexpected_0x0300:
0300: 11 60 03    LD DE,msg_unknown_error_0x0360
0303: CD E0 03    CALL print_string_dollar_0x03E0
0306: C9          RET

;; messages

msg_reading_0x0307:
0307: .db "reading system tracks$", 0x24
; bytes:
; 0x0A 0x0D 0x72 0x65 0x61 0x64 0x69 0x6E 0x67
; 0x20 0x73 0x79 0x73 0x74 0x65 0x6D 0x20 0x74
; 0x72 0x61 0x63 0x6B 0x73 0x24

msg_sector_not_found_0x031F:
031F: .db "CRC error$", 0x24

msg_crc_error_0x032B:
032B: .db "SECTOR not found$", 0x24

msg_idcrc_error_0x033E:
033E: .db "Missing address mark$", 0x24

msg_protect_or_misc_0x0355:
0355: .db "Overrun$", 0x24

msg_unknown_error_0x0360:
0360: .db "not reached$", 0x24

;; Dump Floppy Controller Registers (debug?)
dma_show_regstate_0x03A2:
03A2: CD E0 03    CALL print_string_dollar_0x03E0     ; Print next string from DE
03A5: 3A 0B DF    LD A,(0DF0Bh)                       ; Load controller register #1
03A8: CD BA 03    CALL put_hex_byte_0x03BA

03AB: 0E 20       LD C,20h                             ; ASCII space
03AD: CD D5 03    CALL wait_and_putchar_0x03D5

03B0: 3A 0C DF    LD A,(0DF0Ch)                       ; Load controller register #2
03B3: CD BA 03    CALL put_hex_byte_0x03BA

03B6: C9          RET

;; Convert A to Hex and Print 
put_hex_byte_0x03BA:
03BA: 47          LD B,A
03BB: 0F          RRCA
03BC: 0F          RRCA
03BD: 0F          RRCA
03BE: 0F          RRCA           ; Upper nibble → lower
03BF: E6 0F       AND 0Fh        ; Mask nibble
03C1: CD C7 03    CALL hex_nibble_to_ascii_0x03C7

03C4: 78          LD A,B         ; Restore full byte
03C5: E6 0F       AND 0Fh        ; Get lower nibble

hex_nibble_to_ascii_0x03C7:
03C7: FE 0A       CP 0Ah
03C9: FA CE 03    JP M,putchar_ascii_0x03CE   ; 0–9
03CC: C6 07       ADD A,07h                   ; 'A'–'F'

;; Convert Nibble to ASCII Hex & Print 
putchar_ascii_0x03CE:
03CE: C6 30       ADD A,30h                  ; ASCII encode
03D0: 4F          LD C,A
03D1: CD D5 03    CALL wait_and_putchar_0x03D5
03D4: C9          RET

;; Wait for Output Ready and Print Character
wait_and_putchar_0x03D5:
03D5: DB D9       IN A,(0D9h)                ; Status port
03D7: E6 04       AND 04h                    ; TX buffer empty?
03D9: CA D5 03    JP Z,wait_and_putchar_0x03D5 ; Wait until ready

03DC: 79          LD A,C
03DD: D3 D8       OUT (0D8h),A               ; Send character
03DF: C9          RET

;; Print $-Terminated String
print_string_dollar_0x03E0:
03E0: 1A          LD A,(DE)
03E1: FE 24       CP 24h                     ; Is it '$'?
03E3: C8          RET Z                      ; End of string

03E4: 4F          LD C,A
03E5: CD D5 03    CALL wait_and_putchar_0x03D5
03E8: 13          INC DE
03E9: C3 E0 03    JP print_string_dollar_0x03E0

;; Send Command Byte to DMA
dma_send_cmd_0x03EC:
03EC: F5          PUSH AF

; Wait until controller is ready (bit 7 cleared, bit 6 set)
dma_wait_ready_0x03ED:
03ED: DB F0       IN A,(0F0h)                ; Read DMA/FDC status
03EF: E6 C0       AND 0C0h                   ; Mask bits 7 and 6
03F1: FE 80       CP 80h                     ; Wait for 10xxxxxx (bit 7 clear, bit 6 set)
03F3: C2 ED 03    JP NZ,dma_wait_ready_0x03ED

03F6: F1          POP AF
03F7: D3 F1       OUT (0F1h),A               ; Send command to DMA/FDC
03F9: C9          RET

;; Read Data Byte from DMA
dma_read_result_0x03FA:
03FA: DB F0       IN A,(0F0h)                ; Read FDC status
03FC: E6 C0       AND 0C0h
03FE: FE C0       CP 0C0h                    ; Wait for 11xxxxxx (READY TO READ)
0400: C2 FA 03    JP NZ,dma_read_result_0x03FA

0403: DB F1       IN A,(0F1h)                ; Read data/result byte from ctr
0405: C9          RET

;; --- Configure IM2 Vector Table and Interrupt Hardware ---
setup_im2_0x0406:
0406: F3          DI                          ; Disable interrupts
0407: ED 5E       IM 2                        ; Set Z80 to Interrupt Mode 2
0409: 21 18 02    LD HL,0218h                 ; IM2 vector table base address

040C: 7D          LD A,L                      ; L = 0x18
040D: D3 E8       OUT (0E8h),A                ; Set floppy controller IM2 vector low byte
040F: D3 C8       OUT (0C8h),A                ; Set CTC vector base (IM2)

0411: 7C          LD A,H                      ; H = 0x02
0412: ED 47       LD I,A                      ; Set I = 0x02 → vector table = 0x200–0x2FF

0414: FB          EI                          ; Enable interrupts

;; Configure and Send FDC Command Sequence
0415: 76          HALT                        ; Wait for interrupt
0416: 3E 08       LD A,08h
0418: CD EC 03    CALL dma_send_cmd_0x03EC    ; Send command 0x08

041B: CD FA 03    CALL dma_read_result_0x03FA
041E: CD FA 03    CALL dma_read_result_0x03FA

0421: 3E 03       LD A,03h
0423: CD EC 03    CALL dma_send_cmd_0x03EC    ; Send command 0x03

; Compose complex command from high and low nibble
0426: 3E 0E       LD A,0Eh
0428: E6 0F       AND 0Fh                     ; Lower nibble
042A: 07          RLCA
042B: 07          RLCA
042C: 07          RLCA
042D: 07          RLCA                        ; Shift left 4 → upper nibble

042E: 47          LD B,A                      ; Save upper nibble in B
042F: 3E 0E       LD A,0Eh
0431: E6 0F       AND 0Fh                     ; Lower nibble

0433: B0          OR B                        ; Combine nibbles
0434: CD EC 03    CALL dma_send_cmd_0x03EC    ; Send command

; Setup next parameter
0437: 3E 04       LD A,04h
0439: 07          RLCA                        ; Shift left once
043A: E6 FE       AND 0FEh                    ; Mask low bit (even number)

043C: CD EC 03    CALL dma_send_cmd_0x03EC    ; Send this final command
043F: C9          RET

;; DMA Activation & Sync
dma_action_1_0x0440:
0440: 3E 07       LD A,07h
0442: CD EC 03    CALL dma_send_cmd_0x03EC       ; Send 0x07 command to FDC (maybe RESTORE)

0445: 3A 01 DF    LD A,(0DF01h)                  ; Read controller register/status
0448: CD EC 03    CALL dma_send_cmd_0x03EC       ; Echo it back?

044B: FB          EI                             ; Enable interrupts
044C: 76          HALT                           ; Wait for interrupt

044D: 3E 08       LD A,08h
044F: CD EC 03    CALL dma_send_cmd_0x03EC       ; Send command 0x08 (Sense Interrupt Status)

0452: CD FA 03    CALL dma_read_result_0x03FA    ; Read response #1
0455: CD FA 03    CALL dma_read_result_0x03FA    ; Read response #2

0458: 3E FF       LD A,0FFh
045A: 32 06 DF    LD (0DF06h),A                  ; Save status: initialization success?

045D: C9          RET

;; Write 17-Byte DMA Configuration Block
dma_write_config_0x045E:
045E: 0E C0       LD C,0C0h                  ; DMA data port (command or config input)
0460: 06 11       LD B,17                    ; 17 bytes to send
0462: ED B3       OTIR                       ; Output HL[0..16] → (C), auto-increment
0464: CD AE 04    CALL dma_check_irq_0x04AE  ; After writing, validate IRQ status
0467: C0          RET NZ                     ; Return early if check failed

;; Send DMA Setup Command and IRQ Config (FDC "Read Sector"?)
0468: 3E 46       LD A,46h
046A: CD 0A 05    CALL send_controller_cmd_0x050A ; Log setup sequence + config

046D: CD 26 05    CALL config_irq_mask_0x0526     ; Program IRQ masking/control

0470: FB          EI
0471: 76          HALT

;; IRQ Wait and Controller Dump (CTC motor logic?)
0472: DA 70 04    JP C,0470                   ; If carry set, retry wait (from earlier HALT)

0475: 3E 47       LD A,47h
0477: D3 C8       OUT (0C8h),A                ; Possibly acknowledge IRQ on CTC
0479: D3 C9       OUT (0C9h),A

047B: 3E 64       LD A,64h
047D: D3 C8       OUT (0C8h),A
047F: D3 C9       OUT (0C9h),A

;; Read FDC registers and Store in memory
;; status/result bytes returned from the controller after sector read.
0481: CD FA 03    CALL dma_read_result_0x03FA
0484: 32 07 DF    LD (0DF07h),A               ; Save result #1

0487: CD FA 03    CALL dma_read_result_0x03FA
048A: 32 08 DF    LD (0DF08h),A               ; Save result #2

048D: CD FA 03    CALL dma_read_result_0x03FA
0490: 32 09 DF    LD (0DF09h),A               ; Save result #3

0493: CD FA 03    CALL dma_read_result_0x03FA
0496: 32 0A DF    LD (0DF0Ah),A               ; Save result #4

0499: CD FA 03    CALL dma_read_result_0x03FA
049C: 32 0B DF    LD (0DF0Bh),A               ; Save result #5

049F: CD FA 03    CALL dma_read_result_0x03FA
04A2: 32 0C DF    LD (0DF0Ch),A               ; Save result #6

;; Final Status Check (Ready bit)
04A5: CD FA 03    CALL dma_read_result_0x03FA
04A8: 3A 08 DF    LD A,(0DF08h)               ; Load result byte #2 again
04AB: E6 7F       AND 7Fh                     ; Clear bit 7
04AD: C9          RET

;; DMA Status Verification & Change Detection
dma_check_irq_0x04AE:
04AE: CD 78 05    CALL dma_wait_ready_byte_0x0578   ; Wait for controller to be ready

04B1: 3A 02 DF    LD A,(0DF02h)                     ; Read control/status value
04B4: E6 01       AND 01h                            ; Isolate bit 0 (status flag?)
04B6: 32 05 DF    LD (0DF05h),A                     ; Save current flag A → 0DF05h

04B9: 3A 02 DF    LD A,(0DF02h)                     ; Re-read control register
04BC: 0F          RRCA                               ; Move bit 0 into carry
04BD: E6 7F       AND 7Fh                            ; Mask off bit 7
04BF: 32 04 DF    LD (0DF04h),A                     ; Save processed status
04C2: 47          LD B,A

;; Check against prev value, if changed mark new status
04C3: 3A 06 DF    LD A,(0DF06h)                     ; Get old status (from earlier config)
04C6: A8          XOR B                             ; Detect change
04C7: C8          RET Z                             ; Return if no change → done

;; Retry and Status Recovery Sequence
04C8: 3E 0F       LD A,0Fh
04CA: CD EC 03    CALL dma_send_cmd_0x03EC          ; Send command 0Fh to DMA/FDC

04CD: CD FB 04    CALL dma_finalize_check_0x04FB    ; Internal flag handler
04D0: CD EC 03    CALL dma_send_cmd_0x03EC          ; Re-send latest command (redundant?)

04D3: 3A 04 DF    LD A,(0DF04h)                     ; Load updated status byte
04D6: CD EC 03    CALL dma_send_cmd_0x03EC          ; Final confirmation send

04D9: FB          EI
04DA: 76          HALT                              ; Wait for IRQ

;; Post-HALT Status Validation Loop
04DB: 3E 08       LD A,08h
04DD: CD EC 03    CALL dma_send_cmd_0x03EC          ; Sense status again

04E0: CD FA 03    CALL dma_read_result_0x03FA
04E3: CD FA 03    CALL dma_read_result_0x03FA
04E6: 32 06 DF    LD (0DF06h),A                     ; Save final status register
04E9: 47          LD B,A
04EA: 3A 04 DF    LD A,(0DF04h)
04ED: B8          CP B
04EE: CA F9 04    JP Z,irq_success_0x04F9            ; If match, everything's OK

04F1: 3E FF       LD A,0FFh
04F3: 32 06 DF    LD (0DF06h),A                     ; Mark error flag
04F6: 3E 01       LD A,01h
04F8: C9          RET

;; IRQ Success Path
irq_success_0x04F9:
04F9: AF          XOR A        ; A = 0
04FA: C9          RET          ; Indicate success

;; DMA Finalize Control Check
dma_finalize_check_0x04FB:
04FB: 3A 05 DF    LD A,(0DF05h)     ; Load previously latched bit (bit 0)
04FE: 07          RLCA              ; Bit 0 → bit 1
04FF: 07          RLCA              ; Bit 1 → bit 2
0500: E6 04       AND 04h           ; Isolate bit 2 (former bit 0)
0502: C5          PUSH BC
0503: 47          LD B,A            ; Save to B

0504: 3A 01 DF    LD A,(0DF01h)     ; Read control register again
0507: B0          OR B              ; OR with shifted bit (merge flags)
0508: C1          POP BC
0509: C9          RET

;; Log DMA Status Registers
send_controller_cmd_0x050A:
050A: CD EC 03    CALL dma_send_cmd_0x03EC     ; Send current A (usually a command)

050D: CD FB 04    CALL dma_finalize_check_0x04FB ; Merge and OR in flag bits

0510: CD EC 03    CALL dma_send_cmd_0x03EC     ; Send merged control byte (A)

0513: 3A 04 DF    LD A,(0DF04h)                ; Get byte processed from control register
0516: CD EC 03    CALL dma_send_cmd_0x03EC     ; Send it

0519: 3A 05 DF    LD A,(0DF05h)                ; Get bit flags
051C: CD EC 03    CALL dma_send_cmd_0x03EC     ; Send it

051F: 3A 03 DF    LD A,(0DF03h)                ; Get IRQ configuration or result
0522: CD EC 03    CALL dma_send_cmd_0x03EC     ; Send it

0525: C9          RET

;; Configure IRQ Masks and Final Controller State
config_irq_mask_0x0526:
0526: 3E 01       LD A,01h
0528: CD EC 03    CALL dma_send_cmd_0x03EC       ; Send 0x01

052B: 3E 12       LD A,12h
052D: CD EC 03    CALL dma_send_cmd_0x03EC       ; Send 0x12

0530: 3E 0A       LD A,0Ah
0532: CD EC 03    CALL dma_send_cmd_0x03EC       ; Send 0x0A

0535: 3E FF       LD A,0FFh
0537: CD EC 03    CALL dma_send_cmd_0x03EC       ; Send 0xFF

053A: C9          RET

;; routine Zero A, Enable Interrupts, and Return
dma_clear_and_exit_0x053B:
053B: AF          XOR A             ; A ← 0
053C: FB          EI                ; Enable interrupts
053D: ED 4D       RETI              ; Return from interrupt (IM2)

;; Lonesome RETI
053E: ED 4D       RETI              ; Likely default IM2 entry

;; --------------------------------------------------------------------------
;; Static DMA Configuration Block 1
;; Used by dma_write_config_0x045E to initialize DMA transfer parameters
;; --------------------------------------------------------------------------

dma_config1_0x053F:
053F: C3 05 CF    JP dma_jump_target_0xCF05     ; Trap or ISR redirection
0542: 79          .db 0x79                      ; Drive/head/side flags (01111001b)
0543: 00          .db 0x00                      ; Track number = 0
0544: E0          .db 0xE0                      ; Sector ID (placeholder or real)
0545: FF          .db 0xFF                      ; Sector length (invalid, placeholder?)
0546: 11          .db 0x11                      ; DMA buffer addr = 0x2814
0547: 14          .db 0x14
0548: 28          .db 0x28
0549: 85          .db 0x85                      ; Sector count or flags
054A: F1          .db 0xF1                      ; FDC command: READ SECTOR?
054B: 8A          .db 0x8A                      ; DTL or flags
054C: CF          .db 0xCF                      ; Gap or control byte
054D: 01          .db 0x01                      ; Parameter
054E: CF          .db 0xCF                      ; Possibly command tail or mirror
054F: 87          .db 0x87                      ; Final control/status byte

;; --------------------------------------------------------------------------
;; Static DMA Configuration Block 2
;; Retry or alternate version with sector ID = 0xF2
;; --------------------------------------------------------------------------

dma_config2_0x0550:
0550: C3 05 CF    JP dma_jump_target_0xCF05     ; Same trap jump as above
0553: 79          .db 0x79                      ; Drive/head/side flags
0554: 00          .db 0x00                      ; Track number = 0
0555: F2          .db 0xF2                      ; Different sector ID
0556: FF          .db 0xFF                      ; Sector length placeholder
0557: 11          .db 0x11                      ; DMA buffer addr = 0x2814
0558: 14          .db 0x14
0559: 28          .db 0x28
055A: 85          .db 0x85                      ; Same flags
055B: F1          .db 0xF1                      ; Same read command
055C: 8A          .db 0x8A                      ; Same DTL
055D: CF          .db 0xCF                      ; Gap byte or status/control
055E: 01          .db 0x01                      ; Command parameter
055F: CF          .db 0xCF                      ; Same as above
0560: 87          .db 0x87                      ; End / confirmation byte


;; DMA Status Read via I/O Port 0x98
dma_check_busy_0x0561:
0561: 52          LD D,D                 ; Artifact or padding (no effect)
0562: 4F          LD C,A                 ; Possibly unfinished instruction?

dma_input_check_0x0563:
0563: DB 98       IN A,(98h)             ; Read status from DMA or disk controller
0565: E6 01       AND 01h                ; Check bit 0 (ready/busy flag)
0567: C9          RET

;; Reset Port 0x98 and Perform Delay Loops
;; inner loop 150x, outer loop 220x
dma_reset_0x0568:
0568: AF          XOR A                  ; A ← 0
0569: D3 98       OUT (98h),A            ; Reset status?

delay_outer_loop_0x056B:
056B: 3E DC       LD A,0DCh              ; Outer loop count = 0xDC (220 decimal)

delay_loop_1_0x056D:
056D: 06 96       LD B,96h               ; Inner loop = 150 cycles per outer
delay_loop_2_0x056F:
056F: 05          DEC B
0570: C2 6F 05    JP NZ,delay_loop_2_0x056F

0573: 3D          DEC A
0574: C2 6D 05    JP NZ,delay_loop_1_0x056D

0577: C9          RET

;; Wait Until Controller Is Ready 
dma_wait_ready_byte_0x0578:
0578: CD 63 05    CALL dma_input_check_0x0563   ; Read IN A,(98h), check bit 0
057B: C2 81 05    JP NZ,dma_wait_ready_loop_0x0581 ; If not ready, loop

;; Controller Reset and IRQ Trigger

057E: CD 68 05    CALL dma_reset_0x0568        ; Reset DMA port
0581: AF          XOR A
0582: D3 98       OUT (98h),A                  ; Reset again (redundant?)

0584: 3E 03       LD A,03h
0586: D3 C8       OUT (0C8h),A                 ; Write to CTC or DMA mask register
0588: D3 C9       OUT (0C9h),A

058A: 3E 47       LD A,47h
058C: D3 C8       OUT (0C8h),A                 ; Command to CTC channel 0
058E: 3E FF       LD A,0FFh
0590: D3 C9       OUT (0C9h),A                 ; Full mask or end-of-interrupt?

0592: 3E A0       LD A,0A0h
0594: D3 C8       OUT (0C8h),A
0596: D3 C9       OUT (0C9h),A                 ; These may adjust timer or mask bits
0598: C9          RET

;; Print “DISK NOT READY” Error Message
0599: CD 81 05    CALL dma_error_wait_0x0581     ; Wait for ready after reset
059C: 11 A6 05    LD DE,msg_disk_not_ready_0x05A6
059F: CD E0 03    CALL print_string_dollar_0x03E0 ; Print string until '$'
05A2: 37          SCF                            ; Set Carry Flag (error signal)
05A3: FB          EI                             ; Enable interrupts
05A4: ED 4D       RETI                           ; Return from interrupt

msg_disk_not_ready_0x05A6:
05A6: 0A          .db 0x0A        ; Line feed
05A7: 0D          .db 0x0D        ; Carriage return
05A8: 44          .db 'D'
05A9: 49          .db 'I'
05AA: 53          .db 'S'
05AB: 4B          .db 'K'
05AC: 20          .db ' '
05AD: 4E          .db 'N'
05AE: 4F          .db 'O'
05AF: 54          .db 'T'
05B0: 20          .db ' '
05B1: 52          .db 'R'
05B2: 45          .db 'E'
05B3: 41          .db 'A'
05B4: 44          .db 'D'
05B5: 59          .db 'Y'
05B6: 20          .db ' '
05B7: 21          .db '!'
05B8: 21          .db '!'
05B9: 21          .db '!'
05BA: 24          .db '$'         ; End of string marker

;; possibly text "filler" between strings
05BB: 21 21 21    LD HL,2121h
05BE: 21 21 21    LD HL,2121h
05C1: 21 21 21    LD HL,2121h
05C4: 21 21 24    LD HL,2421h   ; Possibly different to signal end of border
;; more strange letters
05C5: 65          .db 'e'
05C6: 72          .db 'r'
05C7: 72          .db 'r'
05C8: 33          .db '3'
05C9: 0D          .db 0x0D      ; CR
05CA: 0A          .db 0x0A      ; LF
05CB: 09          .db 0x09      ; TAB
05CC: 6C          .db 'l'
05CD: 64          .db 'd'
05CE: 61          .db 'a'
05CF: 20          .db ' '
05D0: 73          .db 's'
05D1: 74          .db 't'
05D2: 61          .db 'a'
05D3: 74          .db 't'
05D4: 31          .db '1'
05D5: 20          .db ' '
05D6: 21          .db '!'
05D7: 20          .db ' '
05D8: 61          .db 'a'
05D9: 6E          .db 'n'
05DA: 69          .db 'i'
05DB: 20          .db ' '
05DC: 31          .db '1'
05DD: 30          .db '0'
05DE: 68          .db 'h'
05DF: 20          .db ' '
05E0: 20          .db ' '
05E1: 20          .db ' '
05E2: 20          .db ' '
05E3: 21          .db '!'
05E4: 20          .db ' '
05E5: 63          .db 'c'
05E6: 6E          .db 'n'
05E7: 7A          .db 'z'
05E8: 20          .db ' '
05E9: 65          .db 'e'
05EA: 72          .db 'r'
05EB: 72          .db 'r'
05EC: 35          .db '5'
05ED: 0D          .db 0x0D
05EE: 0A          .db 0x0A

msg_loading_system_track_0x05EF:
05EF: 6C          .db 'l'
05F0: 64          .db 'd'
05F1: 61          .db 'a'
05F2: 20          .db ' '
05F3: 73          .db 's'
05F4: 74          .db 't'
05F5: 61          .db 'a'
05F6: 74          .db 't'
05F7: 31          .db '1'
05F8: 20          .db ' '
05F9: 21          .db '!'
05FA: 20          .db ' '
05FB: 61          .db 'a'
05FC: 6E          .db 'n'
05FD: FF          .db 0xFF
05FE: FF          .db 0xFF
05FF: FF          .db 0xFF
0600: FF          .db 0xFF
0601: FF          .db 0xFF
0602: FF          .db 0xFF

;; RST38 trap
; 0x0603 onward: filled with RST 38h (0xFF) = unhandled trap

0603: FF          RST 38h
0604: FF          RST 38h
0605: FF          RST 38h
0606: FF          RST 38h
0607: FF          RST 38h
0608: FF          RST 38h
0609: FF          RST 38h
060A: FF          RST 38h
060B: FF          RST 38h
060C: FF          RST 38h
060D: FF          RST 38h
060E: FF          RST 38h
060F: FF          RST 38h
0610: FF          RST 38h
0611: FF          RST 38h
0612: FF          RST 38h
0613: FF          RST 38h
0614: FF          RST 38h
0615: FF          RST 38h
0616: FF          RST 38h
0617: FF          RST 38h

